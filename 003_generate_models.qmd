---
title: "Model generation"
author: "Kevin Horan"
execute: 
  echo: false
  warning: false
  message: false
  code-fold: false
  cache: false
toc: true
number-sections: false
format:
  pdf: default
  html: 
    code-fold: true
    html-math-method: katex
editor: source
bibliography: references.bib
---

```{r, warning=FALSE, message=FALSE}

# install.packages("devtools")
# devtools::install_github("m-clark/gammit")

packages <- c(
  "MASS",
  "tidyverse",
  "sf",
  "tmap",
  "here",
  "spdep", # areal data
  "grid",
  "GWmodel",
  "gstat",
  "kableExtra",
  "cowplot",
  "cartogram",
  "parlitools",
  "corrplot",
  "lme4",
  "mgcv",
  "ggfortify",
  "ggforce", # has geom_circle
  "gridExtra",
  "car",
  "rgeoda", # for LISA
  "ggpubr",
  "ggrepel",
  "ggpointdensity",
  "ggalt", # for geom_encircle
  "ggsflabel", # has repel labels for sf
  "viridis",
  "spatialreg",
  "rgdal",
  "rgeos",
  "randomForest",
  "broom",
  "patchwork",
  "nlme",
  "paletteer", # easy access to many palettes (eg >10 discrete colours...)
  "broom.mixed", # extract tidy output
  "merTools", # with plot functions
  "DiagrammeR", # mermaid
  "gammit" # for pulling out ran and fixed effs
  )


# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))

options(kableExtra.latex.load_packages = TRUE)

tmap_mode("plot")
rm(list=ls())

```

```{r}

# avoid conflict with dplyr and MASS::select
select <- dplyr::select

set.seed(123)

```

```{r, warning=FALSE, message=FALSE}

df <- readRDS("/Users/kevinhoran/Library/CloudStorage/OneDrive-MaynoothUniversity/swing_project/data/df.rds") |> 
  mutate(degree_educated = degree,
         professionals = industry_professional,
         younger_adults = age_18_to_19 + age_20_to_24 + age_25_to_29 + age_30_to_44,
         english_speaking = english_all,
         single_ethnicity_household = 100 - ethnicity_mixed,
         health_not_good = health_fair + health_bad + health_very_bad,
         deprived = deprived_1 + deprived_2 + deprived_3,
         white = ethnicity_white,
         christian = christian,
         own_home = house_owned,
         no_car = cars_none,
         density = density,
         region = as.character(region),
         region = factor(ifelse(county == "Merseyside", "Merseyside", region)),
         region = factor(region)) |> 
  st_as_sf() |> 
  st_transform(crs=27700)

hex <- west_hex_map
df_hex <- df |> 
  st_drop_geometry() |> 
  inner_join(hex |> select(-"constituency_name"), #  no letter case confusion
             by = c("ons_const_id"="gss_code")) |> 
  st_as_sf()

hex_regions <- df_hex |> 
  group_by(region) |> 
  summarise() |> 
  st_as_sf()

regions <- df |> group_by(region) |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)


vardf <- data.frame(variable = c("degree_educated",
               "professionals",
               "younger_adults",
               "english_speaking",
               "single_ethnicity_household",
               "deprived",
               "white",
               "christian",
               "own_home",
               "no_car"))

var_justification <- data.frame(
  variable = c("degree_educated",
               "professionals",
               "younger_adults",
               "english_speaking",
               "single_ethnicity_household",
               "deprived",
               "white",
               "christian",
               "own_home",
               "no_car"),
  justification = c(rep("post-industrial / knowledge economy",3),
                    rep("diversity / values / outcomes",5),
                    rep("metropolitan / 'big-city'",2)),
  jcolour = c(rep("navyblue",3),
                    rep("firebrick4",5),
                    rep("darkgreen",2))
)


# scale the variables to better judge relative strength of effects
df_scaled <- df |> 
  st_drop_geometry() |> 
  select(degree_educated,
    professionals,
    younger_adults,
    english_speaking,
    single_ethnicity_household,
    health_not_good,
    white,
    christian,
    own_home,
    no_car) |> 
  scale() |> 
  as.data.frame() |> 
  mutate(con_swing=df$con_swing,
         region=df$region)


df_scaled_sf <- df_scaled |> 
  mutate(constituency_name = df$constituency_name, 
         geometry = df$geometry) |> 
  st_as_sf()

```

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

nlistreg <- regions %>% st_touches()
names(nlistreg) <- regions$region
df_sc_region <- df_scaled_sf |> 
  st_drop_geometry() |> 
  left_join(regions) |> 
  st_as_sf()

```

\clearpage

## Linear Mixed Model structure

Mixed models are an extension of simple linear models to allow both fixed and random effects, and are particularly suitable when there is non independence in the data, such as arises from a hierarchical structure. With multiple levels, the variability in the outcome can be thought of as being either within group or between group. By applying a mixed model to spatial data which is divided into regions, much of the non-independence of the global data can instead be modelled as acceptable within-region non-independence. In this context, swing in 571 constituencies, each contained within one of 11 regions, is being explained by four explanatory variables.

Structure of basic linear mixed model: $$ \mathbf{y}=\mathbf{X}\pmb{\beta}+\mathbf{Zu}+\pmb{\epsilon} $$

where $\mathbf{y}$ is a 571 $\times$ 1 column vector of swing for each constituency;

$\mathbf{X}$ is a 571 $\times$ 5 matrix, whose first column is a column of 1s for the intercept and whose remaining 4 columns contain the predictor variables;

$\pmb{\beta}$ is a 5 $\times$ 1 column vector of the intercept and fixed effects regression coefficients;

$\mathbf{Z}$ is the 571 $\times$ (11 $\times$ 5) design matrix for the random effects of 11 regions for intercept and 4 explanatory variables;

$\mathbf{u}$ is an 11 $\times$ 1 vector of random effects;

and $\pmb{\epsilon}$ is a 571 $\times$ 1 column vector of the residuals, the part of $\mathbf{y}$ that is not explained by the model.

If we estimated $\mathbf{u}$, it would be a column vector, similar to $\pmb{\beta}$. However, instead we assume that: $$ \mathbf{u}\sim\mathcal{N}(\mathbf{0},\mathbf{G})$$

where $\mathbf{G}$ is the variance-covariance matrix of the random effects. Because we directly estimated the fixed effects, including the fixed effect intercept, random effect complements are modelled as deviations from the fixed effect, so they have mean zero. The means that what is left to estimate is the variance. $\mathbf{G}$ is a 5 $\times$ 5 matrix;

$$\mathbf{G} = \begin{bmatrix}
\pmb{\sigma^2_{int}}
&\sigma^2_{int,degree}
&\sigma^2_{int,young}
&\sigma^2_{int,badhealth}
&\sigma^2_{int,white} \\
\sigma^2_{int,degree}
&\pmb{\sigma^2_{degree}}
&\sigma^2_{degree,young}
&\sigma^2_{degree,badhealth}
&\sigma^2_{degree,white} \\
\sigma^2_{int,young}
&\sigma^2_{degree,young}
&\pmb{\sigma^2_{young}}
&\sigma^2_{young,badhealth}
&\sigma^2_{young,white} \\
\sigma^2_{int,badhealth}
&\sigma^2_{degree,badhealth}
&\sigma^2_{young,badhealth}
&\pmb{\sigma^2_{badhealth}}
&\sigma^2_{badhealth,white} \\
\sigma^2_{int,white}
&\sigma^2_{degree,white}
&\sigma^2_{young,white}
&\sigma^2_{badhealth,white}
&\pmb{\sigma^2_{white}} \\
\end{bmatrix}$$

Because it is a variance-covariance matrix, it must be square, symmetric, and positive semidefinite. Furthermore, this matrix has redundant elements. For a $q\times q$ matrix, there are $\frac{q(q+1)}{2}$ unique elements. To simplify computation by removing redundant effects and ensure that the resulting estimate matrix is positive definite, rather than model $\mathbf{G}$ directly, we estimate $\pmb{\theta}$ (e.g., a triangular Cholesky factorization $\mathbf{G}$=$\mathbf{LDL^T}$). $\pmb{\theta}$ is not always parameterised the same way, but can generally be thought of as representing the random effects. It is usually designed to contain non redundant elements (unlike the variance covariance matrix) and to be parameterised in a way that yields more stable estimates than variances (such as taking the natural logarithm to ensure that the variances are positive). Regardless of the specifics, $\mathbf{G}$ is some function of $\pmb{\theta}$:
$$\mathbf{G}=\sigma(\pmb{\theta})$$

for which an estimate of $\pmb{\hat{\theta}}$ is obtained. Here the model is simplified by assuming that the random effects are independent, which would imply the structure is

$$\mathbf{G} = \begin{bmatrix}
\sigma^2_{int}
&0
&0
&0
&0 \\
0
&\sigma^2_{degree}
&0
&0
&0 \\
0&0
&\sigma^2_{young}
&0
&0 \\
0&0
&0
&\sigma^2_{badhealth}
&0 \\
0
&0
&0
&0
&\sigma^2_{white} \\
\end{bmatrix}$$

The final element of the model is the variance-covariance matrix of the residuals, $\epsilon$ or the variance-covariance matrix of conditional distribution of $(\mathbf{y}|\pmb{\beta};\mathbf{u}=u)$. The most common residual covariance structure is $$
\mathbf{R}=\mathbf{I}\pmb{\sigma^2_\epsilon}
$$

where $\mathbf{I}$ is the identity matrix and $\sigma^2_\epsilon$ is the residual variance. This structure assumes a homogeneous residual variance for all (conditional) observations and that they are (conditionally) independent. Other structures can be assumed such as compound symmetry or autoregressive.

So the final fixed elements are $\mathbf{y}$, $\mathbf{X}$, $\mathbf{Z}$, and $\pmb{\epsilon}$. The final estimated elements are $\pmb{\hat{\beta}}$, $\pmb{\hat{\theta}}$, and $\mathbf{\hat{R}}$. The final model is of the form:

$$ (\mathbf{y}|\pmb{\beta};\mathbf{u}=u) \sim \mathcal{N}(\mathbf{X}\pmb{\beta}+\mathbf{Z}u,\mathbf{R})$$ 

\clearpage

## Create models

-   Start by creating a simple OLS model, then the same model with a spatial component added to it.

-   Then create a mixed model by region, using `lme4` with uncorrelated random effects. This model is then recreated precisely in `mgcv` and `nmle` to allow extra features to be introduced.

-   Create the same model in `lme4` but, this time, allowing for correlation between the random intercept and coefficients.

-   Use the model constructed in `nlme` and use that package's built in features to account for spatial autocorrelation, making three different models.

-   Finally, add spatial components to the `mgcv` GAM version of the mixed model.

```{r}
#| code-fold: false
#| message: false
#| warning: false
#| echo: true

# not mixed models
mod_lm <- lm(con_swing ~
               degree_educated +
               younger_adults +
               health_not_good +
               white,
             data=df_scaled_sf)

mod_lm_mrf <- gam(con_swing ~
                    degree_educated +
                    younger_adults +
                    health_not_good +
                    white + 
                    s(region,bs='mrf',xt=list(nb=nlistreg)),
                  data=df_sc_region, method="REML")

###

# these three mixed models, essentially the same
mod_mixed_lmer <- 
  lmer(con_swing ~
         degree_educated +
         younger_adults +
         health_not_good +
         white +
         (1+degree_educated+younger_adults+health_not_good+white||region), 
       df_scaled, REML = TRUE)

mod_mixed_gam <- 
  gam(con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white + 
        s(region, bs="re") +
        s(degree_educated,region, bs="re") +
        s(younger_adults,region, bs="re") +
        s(health_not_good,region, bs="re") +
        s(white,region, bs="re"),
      data=df_sc_region, method="REML")

mod_mixed_nlme <- 
  lme(fixed = con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white,
      random = list(region = pdDiag(
        ~1+degree_educated+younger_adults+health_not_good+white)), 
      data=df_sc_region, method = "REML")

###

## lme4 model with correlated intercepts and slopes
mod_mixed_lmer_correl <- 
  lmer(con_swing ~
         degree_educated +
         younger_adults +
         health_not_good +
         white +
         (1+degree_educated+younger_adults+health_not_good+white|region), 
       df_scaled, REML = TRUE)

###

## nlme models with spatial autocorrelation

## first make df with X and Y coords, and crs 27700
centroids <- 
  df |> st_transform(crs=27700) |> st_centroid() |> st_coordinates() |> 
  cbind(df |> st_drop_geometry() |> select(constituency_name))
  
nlme_df <- df_sc_region |> 
  left_join(centroids, by="constituency_name") |> 
  st_drop_geometry()

mod_nlme_corGaus <- 
  lme(fixed = con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white,
      correlation = corGaus(form = ~X+Y),
      random = list(region = pdDiag(
        ~1+degree_educated+younger_adults+health_not_good+white)),
      data=nlme_df, method = "REML")

mod_nlme_corExp <- 
  lme(fixed = con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white,
      correlation = corExp(form = ~X+Y),
      random = list(region = pdDiag(
        ~1+degree_educated+younger_adults+health_not_good+white)),
      data=nlme_df, method = "REML")

mod_nlme_corLin <- 
  lme(fixed = con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white,
      correlation = corLin(form = ~X+Y),
      random = list(region = pdDiag(
        ~1+degree_educated+younger_adults+health_not_good+white)),
      data=nlme_df, method = "REML")

###

## models with spatial components

## this one, the same as the 3 identical mixed models from above, 
## except region intercept comes from mrf
mod_mixed_gam_v1 <- 
  gam(con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white + 
        s(degree_educated,region, bs="re") +
        s(younger_adults,region, bs="re") +
        s(health_not_good,region, bs="re") +
        s(white,region, bs="re") +
        s(region,bs='mrf',xt=list(nb=nlistreg)),
      data=df_sc_region, method="REML")

## here, each covariate is crossed with mrf of region
mod_mixed_gam_v2 <- 
  gam(con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white + 
        s(region,bs='mrf',xt=list(nb=nlistreg)) +  
        s(region,bs='mrf',xt=list(nb=nlistreg), by=degree_educated) +
        s(region,bs='mrf',xt=list(nb=nlistreg), by=younger_adults) +
        s(region,bs='mrf',xt=list(nb=nlistreg), by=health_not_good) +
        s(region,bs='mrf',xt=list(nb=nlistreg), by=white),
      data=df_sc_region, method="REML")

```

\clearpage

The following are the models constructed in the previous section. Their RMSE, AIC and mean Moran's-I are shown.

### Summary of model outputs

```{r}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

# RMSE
mod_lm_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_lm,df_sc_region))^2) / nrow(df_sc_region))
mod_lm_mrf_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_lm_mrf,df_sc_region))^2) / nrow(df_sc_region))
mod_mixed_lmer_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_mixed_lmer,df_sc_region))^2) / nrow(df_sc_region))
mod_mixed_nlme_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_mixed_nlme,df_sc_region))^2) / nrow(df_sc_region))
mod_mixed_gam_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_mixed_gam,df_sc_region))^2) / nrow(df_sc_region))
mod_mixed_lmer_correl_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_mixed_lmer_correl,df_sc_region))^2) / nrow(df_sc_region))
mod_nlme_corGaus_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_nlme_corGaus,df_sc_region))^2) / nrow(df_sc_region))
mod_nlme_corExp_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_nlme_corExp,df_sc_region))^2) / nrow(df_sc_region))
mod_nlme_corLin_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_nlme_corLin,df_sc_region))^2) / nrow(df_sc_region))
mod_mixed_gam_v1_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_mixed_gam_v1,df_sc_region))^2) / nrow(df_sc_region))
mod_mixed_gam_v2_rmse <- sqrt(sum((df_sc_region$con_swing - predict(mod_mixed_gam_v2,df_sc_region))^2) / nrow(df_sc_region))

# Moran's I
df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_lm) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_lm <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_lm_mrf) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_lm_mrf <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_lmer) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_lmer <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_nlme) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_nlme <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_gam) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_gam <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_lmer_correl) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_lmer_correl <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_nlme_corGaus) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_nlme_corGaus <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_nlme_corExp) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_nlme_corExp <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_nlme_corLin) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_nlme_corLin <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_gam_v1) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_gam_v1 <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_gam_v2) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_gam_v2 <- round(temp_reg$coefficients[2],3)

models_table <- data_frame(
  package = c("base","gam","lme4","gam","nlme","lme4","nlme","nlme","nlme","gam","gam"),
  model = c("mod_lm",
          "mod_lm_mrf",
          "mod_mixed_lmer",
          "mod_mixed_gam",
          "mod_mixed_nlme",
          "mod_mixed_lmer_correl",
          "mod_nlme_corGaus",
          "mod_nlme_corExp",
          "mod_nlme_corLin",
          "mod_mixed_gam_v1",
          "mod_mixed_gam_v2"),
  `Explicitly spatial` = c("No","Yes","No","No","No","No","Yes","Yes","Yes","Yes","Yes"),
  RMSE = c(mod_lm_rmse,
          mod_lm_mrf_rmse,
          mod_mixed_lmer_rmse,
          mod_mixed_gam_rmse,
          mod_mixed_nlme_rmse,
          mod_mixed_lmer_correl_rmse,
          mod_nlme_corGaus_rmse,
          mod_nlme_corExp_rmse,
          mod_nlme_corLin_rmse,
          mod_mixed_gam_v1_rmse,
          mod_mixed_gam_v2_rmse),
  `AIC (min to max)` = c(AIC(mod_lm),
          AIC(mod_lm_mrf),
          AIC(mod_mixed_lmer),
          AIC(mod_mixed_gam),
          AIC(mod_mixed_nlme),
          AIC(mod_mixed_lmer_correl),
          AIC(mod_nlme_corGaus),
          AIC(mod_nlme_corExp),
          AIC(mod_nlme_corLin),
          AIC(mod_mixed_gam_v1),
          AIC(mod_mixed_gam_v2)),
  `Morans-I` = c(m_mod_lm,
          m_mod_lm_mrf,
          m_mod_mixed_lmer,
          m_mod_mixed_gam,
          m_mod_mixed_nlme,
          m_mod_mixed_lmer_correl,
          m_mod_nlme_corGaus,
          m_mod_nlme_corExp,
          m_mod_nlme_corLin,
          m_mod_mixed_gam_v1,
          m_mod_mixed_gam_v2)) |> 
  arrange(`AIC (min to max)`)

kbl(models_table, caption="Summary of model outputs") |> 
  kable_classic(full_width = F, html_font = "Cambria")

```

\clearpage

## 1: Simple linear model

Before moving to mixed models, fit a simple linear model to show why a more complicated model is required.

### mod_lm

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_lm_df <- tidy(mod_lm) |> 
  mutate(conf_lower = confint(mod_lm)[,1],
         conf_upper = confint(mod_lm)[,2])

mod_lm$call

mod_lm_df$swingto <- case_when(mod_lm_df$estimate>0 ~ "Conservative",
                              TRUE ~ "Labour")
ggplot(mod_lm_df,aes(x=estimate, y=term,xmin=conf_lower,xmax=conf_upper,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Coefficients of model: mod_lm") + 
  xlim(-4,6)

# par(mfrow=c(2,2))
# plot(mod_lm)

```

But this simple model leaves residuals which are clearly correlated to those of their neighbours, as can be seen in the following Moran's plot, which violates the assumption of independence.

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of linear model, with fills by region for high leverage constituencies"

temp_mod_lm <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_lm) |> as.numeric())

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_lm$resids, df_wts, zero.policy = TRUE, labels = temp_mod_lm$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

temp_reg <- lm(wx~x,mp)

xname <- attr(mp, "xname")
ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
  geom_smooth(formula=y ~ x, method="lm") + 
  geom_hline(yintercept=mean(mp$wx), lty=2) + 
  geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
  geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
  geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
  guides(fill = "none") +
  xlab("Residuals") + 
  ylab(paste0("Spatially lagged Residuals")) +
  scale_fill_brewer(palette = "Set3") + 
  labs(title = "mod_lm",
       subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
  theme(legend.position = "bottom")

```

\clearpage

## 2: Linear model with mrf

### mod_lm_mrf

#### fixed

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_lm_mrf$call

mod_lm_mrf_fixed <- extract_fixed(mod_lm_mrf)

mod_lm_mrf_fixed$swingto <- case_when(mod_lm_mrf_fixed$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
mod_lm_mrf_fixed$term <- str_replace(mod_lm_mrf_fixed$term, "Intercept","(Intercept)")

ggplot(mod_lm_mrf_fixed,aes(x=value, y=term,xmin=lower_2.5,xmax=upper_97.5,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Model: mod_lm_mrf",
       subtitle = "Fixed Coefficients") + 
  xlim(-4,6)

```

#### spatial

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

{ # for extracting effects with gam...
  temp <- tibble(
    degree_educated=rep(1,nrow(df_scaled_sf)),
    younger_adults=rep(1,nrow(df_scaled_sf)),
    health_not_good=rep(1,nrow(df_scaled_sf)),
    white=rep(1,nrow(df_scaled_sf)),
    no_car=rep(1,nrow(df_scaled_sf)),
    region=df_sc_region$region)
  
  
  mod_lm_mrf_df <- predict(mod_lm_mrf,newdata = temp,type = "terms", se.fit = TRUE) |> 
    as.data.frame() |> 
    cbind(df |> select(geometry,
                       region)) |> 
    as.data.frame() |> 
    st_as_sf()
  
  mod_lm_mrf_reg <- regions |> 
    left_join(mod_lm_mrf_df |> st_drop_geometry(), by="region") |> 
    st_drop_geometry() |> 
    unique() |> 
    left_join(regions, by="region") |> 
    st_as_sf()
}


# mrf region component

temp4 <- mod_lm_mrf_reg[,c(1,6,11)]

names(temp4) <- str_remove(names(temp4),"fit.")
temp4$conf_lower <- temp4$`s.region.` - qnorm(0.975)*temp4$`se.s.region.`
temp4$conf_upper <- temp4$`s.region.` + qnorm(0.975)*temp4$`se.s.region.`
temp4$region <- fct_reorder(temp4$region,temp4$`s.region.`)

temp4$swingto <- case_when(temp4$`s.region.`>0 ~ "Conservative",
                              TRUE ~ "Labour")

mod_lm_mrf_plot1 <- ggplot(temp4,aes(x=`s.region.`, y=region,xmin=conf_lower,xmax=conf_upper,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
  scale_fill_manual(breaks = c("Conservative", "Labour"),
                    values = c("darkblue", "firebrick4")) + 
  scale_colour_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
  geom_vline(xintercept = 0, colour="red") + 
  theme_bw() + 
  labs(title = "Model: mod_lm_mrf",
       subtitle = "Geographic effect")

# map polygons with equal numbers of voters per pixel
region_pop <- df |> 
  st_transform(27700) |> 
  group_by(region) |> 
  summarise(pop = sum(total_vote_19))
  
regions_contig <- cartogram_cont(region_pop,weight="pop") |> 
  mutate(s.region. = temp4$s.region.)
mod_lm_mrf_plot2 <- ggplot(regions_contig) + 
  geom_sf(aes(fill=s.region.), lwd=0.1) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       subtitle = "Region size proportional to population") + 
  theme_bw()
###

# mod_lm_mrf_plot2 <- ggplot(temp4) + 
#   geom_sf(aes(fill=s.region.), lwd=0.1) + 
#   scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
#   coord_sf(datum=NA) + 
#   labs(fill="Geographic\neffect",
#        title = "Model: mod_lm_mrf") + 
#   theme_bw()

mod_lm_mrf_plot1 + mod_lm_mrf_plot2

```

Spatial autocorrelation is reduced by adding MRF spatial component. It acts like a varying intercept by region.

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of linear model, with fills by region for high leverage constituencies"

temp_mod_lm_mrf <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_lm_mrf))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_lm_mrf$resids, df_wts, zero.policy = TRUE, labels = temp_mod_lm_mrf$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

temp_reg <- lm(wx~x,mp)

xname <- attr(mp, "xname")
ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
  geom_smooth(formula=y ~ x, method="lm") + 
  geom_hline(yintercept=mean(mp$wx), lty=2) + 
  geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
  geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
  geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
  guides(fill = "none") +
  xlab("Residuals") + 
  ylab(paste0("Spatially lagged Residuals")) +
  scale_fill_brewer(palette = "Set3") + 
  labs(title = "mod_lm_mrf",
       subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
  theme(legend.position = "bottom")

```

```{r}

library(cartogram)

region_pop <- df |> 
  st_transform(27700) |> 
  group_by(region) |> 
  summarise(pop = sum(population))
  
regions_contig <- cartogram_cont(region_pop,weight="pop")





```

\clearpage

## 3: Mixed model

(using `lme4` package, out of the three equivalent models created above)

### mod_mixed_lmer

#### fixed

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_lmer@call

mod_mixed_lmer_fix <- broom.mixed::tidy(mod_mixed_lmer, effects="fixed", conf.int=TRUE, conf.method = "profile")

#like_rat_pval <- as.data.frame(anova(mm2.2,mm2.1))[2,8]
mod_mixed_lmer_fix$swingto <- case_when(mod_mixed_lmer_fix$estimate>0 ~ "Conservative",
                              TRUE ~ "Labour")
ggplot(mod_mixed_lmer_fix,aes(x=estimate, y=term,xmin=conf.low,xmax=conf.high,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Model: mod_mixed_lmer",
       subtitle = "Fixed coefficients") + 
  xlim(-4,6)

```

#### random

```{r, fig.width=10,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_lmer_rand <- broom.mixed::tidy(mod_mixed_lmer, effects="ran_vals", conf.int=TRUE)

mod_mixed_lmer_plot_list <- list()
i=1
for (var in levels(df_scaled$region)){
  mmtemp <- mod_mixed_lmer_rand[mod_mixed_lmer_rand$level==levels(df_scaled$region)[i],]
  mmtemp$swingto <- case_when(mmtemp$estimate>0 ~ "Conservative",
                              TRUE ~ "Labour")
  mod_mixed_lmer_plot_list[[i]] <- ggplot(mmtemp, aes(x=estimate, y=term,
                                              xmin=conf.low,
                                              xmax=conf.high, 
                                              fill=swingto,
                                              colour=swingto)) + 
    geom_errorbar(lwd=0.5, colour="black") + 
    geom_point(shape=21, size=3) + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
    theme(plot.title =element_text(size=10, face='bold'),
          plot.subtitle =element_text(size=8)) + 
    labs(x="coef effect", 
         y=NULL, 
         title = levels(df_scaled$region)[i]) + 
    guides(fill="none",
           colour="none")
  
  i= i+1
}

(plot_spacer()|plot_spacer()|mod_mixed_lmer_plot_list[[5]]|plot_spacer()) / 
  (plot_spacer()|mod_mixed_lmer_plot_list[[4]]|mod_mixed_lmer_plot_list[[6]]|mod_mixed_lmer_plot_list[[11]]|plot_spacer()) / 
  (mod_mixed_lmer_plot_list[[9]]|mod_mixed_lmer_plot_list[[10]]|mod_mixed_lmer_plot_list[[2]]|mod_mixed_lmer_plot_list[[1]]) /
  (plot_spacer()|mod_mixed_lmer_plot_list[[8]]|mod_mixed_lmer_plot_list[[3]]|mod_mixed_lmer_plot_list[[7]]) +
  plot_annotation(
    title = "Model: mod_mixed_lmer",
    subtitle = "Random intercepts and coefficients",
    theme = theme(plot.title = element_text(size = 16))
  )

```

```{r, fig.width=12, fig.height=4}
# map polygons with equal numbers of voters per pixel
regions_dorling <- cartogram_dorling(region_pop,weight="pop") |> 
  left_join(mod_mixed_lmer_rand, by=c("region"="level")) |> 
  mutate(sig_estimate = case_when(conf.low <0 & conf.high<0 ~ estimate,
                                  conf.low >0 & conf.high>0 ~ estimate,
                                  TRUE ~ 0))

dorl_mod_mixed_lmer <- ggplot(regions_dorling) + 
  geom_sf(aes(fill=sig_estimate)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
  coord_sf(datum=NA) + 
  labs(fill="Random\neffects",
       title = "Model: mod_mixed_lmer",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~term, ncol = 5)

dorl_mod_mixed_lmer

# map polygons with equal numbers of voters per pixel
counties_dorling <- cartogram_dorling(region_pop,weight="pop") |> 
  left_join(mod_mixed_lmer_rand, by=c("region"="level")) |> 
  mutate(signifigant = case_when(conf.low <0 & conf.high<0 ~ "yes",
                                  conf.low >0 & conf.high>0 ~ "yes",
                                  TRUE ~ "no"))

dorl_mod_mixed_lmer_p2 <- ggplot() + 
  geom_sf(data=counties_dorling,aes(fill=estimate,colour=signifigant), linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint=0) + 
  scale_colour_manual(values = c("gray90","black")) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_lmer",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~term, ncol = 5)

dorl_mod_mixed_lmer_p2


```

Spatial autocorrelation is substantially reduced by the mixed model, without adding any explicitly spatial component.

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

temp_mod_mixed_lmer <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_lmer))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_mixed_lmer$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_lmer$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

temp_reg <- lm(wx~x,mp)

xname <- attr(mp, "xname")
ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
  geom_smooth(formula=y ~ x, method="lm") + 
  geom_hline(yintercept=mean(mp$wx), lty=2) + 
  geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
  geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
  geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
  guides(fill = "none") +
  xlab("Residuals") + 
  ylab(paste0("Spatially lagged Residuals")) +
  scale_fill_brewer(palette = "Set3") + 
  labs(title = "mod_mixed_lmer",
       subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
  theme(legend.position = "bottom")

```

\clearpage

## 4: Mixed models with spatial component (x2)

### a: mod_mixed_gam_v1

#### fixed

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_gam_v1$call

mod_mixed_gam_v1_fixed <- extract_fixed(mod_mixed_gam_v1)

mod_mixed_gam_v1_fixed$term <- str_replace(mod_mixed_gam_v1_fixed$term, "Intercept","(Intercept)")
mod_mixed_gam_v1_fixed$swingto <- case_when(mod_mixed_gam_v1_fixed$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
ggplot(mod_mixed_gam_v1_fixed,aes(x=value, y=term,xmin=lower_2.5,xmax=upper_97.5,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Model: mod_mixed_gam_v1",
       subtitle = "Fixed effects") + 
  xlim(-4,6)

```

#### random

```{r, fig.width=10,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_gam_v1_random <- extract_ranef(mod_mixed_gam_v1)


mod_mixed_gam_v1_plot_list <- list()
i=1
for (var in levels(df_scaled$region)){
  mmtemp <- mod_mixed_gam_v1_random[mod_mixed_gam_v1_random$group==levels(df_scaled$region)[i],]
  mmtemp$swingto <- case_when(mmtemp$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
  mod_mixed_gam_v1_plot_list[[i]] <- ggplot(mmtemp, aes(x=value, y=effect,
                                              xmin=lower_2.5,
                                              xmax=upper_97.5, 
                                              fill=swingto,
                                              colour=swingto)) + 
    geom_errorbar(lwd=0.5, colour="black") + 
    geom_point(shape=21, size=3) + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
    theme(plot.title =element_text(size=10, face='bold'),
          plot.subtitle =element_text(size=8)) + 
    labs(x="coef effect", 
         y=NULL, 
         title = levels(df_scaled$region)[i]) + 
    guides(fill="none",
           colour="none")
  
  i= i+1
}

(plot_spacer()|plot_spacer()|mod_mixed_gam_v1_plot_list[[5]]|plot_spacer()) / 
  (plot_spacer()|mod_mixed_gam_v1_plot_list[[4]]|mod_mixed_gam_v1_plot_list[[6]]|mod_mixed_gam_v1_plot_list[[11]]|plot_spacer()) / 
  (mod_mixed_gam_v1_plot_list[[9]]|mod_mixed_gam_v1_plot_list[[10]]|mod_mixed_gam_v1_plot_list[[2]]|mod_mixed_gam_v1_plot_list[[1]]) /
  (plot_spacer()|mod_mixed_gam_v1_plot_list[[8]]|mod_mixed_gam_v1_plot_list[[3]]|mod_mixed_gam_v1_plot_list[[7]]) +
  plot_annotation(
    title = "Model: mod_mixed_gam_v1",
    subtitle = "Random intercepts and coefficients",
    theme = theme(plot.title = element_text(size = 16))
  )

```

```{r, fig.width=12, fig.height=4}

regions_dorling <- cartogram_dorling(region_pop,weight="pop") |> 
  left_join(mod_mixed_gam_v1_random, by=c("region"="group")) |> 
  mutate(sig_estimate = case_when(lower_2.5 <0 & upper_97.5<0 ~ value,
                                  lower_2.5 >0 & upper_97.5>0 ~ value,
                                  TRUE ~ 0))

dorl_mod_mixed_gam_v1 <- ggplot(regions_dorling) + 
  geom_sf(aes(fill=sig_estimate)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_gam_v1",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~effect, ncol = 4)

dorl_mod_mixed_gam_v1

# map polygons with equal numbers of voters per pixel
counties_dorling <- cartogram_dorling(region_pop,weight="pop") |> 
  left_join(mod_mixed_gam_v1_random, by=c("region"="group")) |> 
  mutate(signifigant = case_when(lower_2.5 <0 & upper_97.5<0 ~ "yes",
                                  lower_2.5 >0 & upper_97.5>0 ~ "yes",
                                  TRUE ~ "no"))

dorl_mod_mixed_gam_v1_p2 <- ggplot() + 
  geom_sf(data=counties_dorling,aes(fill=value,colour=signifigant), linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint=0) + 
  scale_colour_manual(values = c("gray90","black")) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_gam_v1",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~effect, ncol = 5)

dorl_mod_mixed_gam_v1_p2

```

#### spatial

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

{ # for extracting effects with gam...
  temp <- tibble(
    degree_educated=rep(1,nrow(df_scaled_sf)),
    younger_adults=rep(1,nrow(df_scaled_sf)),
    health_not_good=rep(1,nrow(df_scaled_sf)),
    white=rep(1,nrow(df_scaled_sf)),
    no_car=rep(1,nrow(df_scaled_sf)),
    region=df_sc_region$region)
  
  
  mod_mixed_gam_v1_df <- predict(mod_mixed_gam_v1,newdata = temp,type = "terms", se.fit = TRUE) |> 
    as.data.frame() |> 
    cbind(df |> select(geometry,
                       region)) |> 
    as.data.frame() |> 
    st_as_sf()
  
  mod_mixed_gam_v1_df_reg <- regions |> 
    left_join(mod_mixed_gam_v1_df |> st_drop_geometry(), by="region") |> 
    st_drop_geometry() |> 
    unique() |> 
    left_join(regions, by="region") |> 
    st_as_sf()
}

mod_mixed_gam_v1_geog <- mod_mixed_gam_v1_df_reg[,c(1,10,19)] |> 
  st_drop_geometry()
names(mod_mixed_gam_v1_geog) <- str_remove(names(mod_mixed_gam_v1_geog),"fit.")
names(mod_mixed_gam_v1_geog) <- c("region","effect","std_error")
mod_mixed_gam_v1_geog$conf_lower <- mod_mixed_gam_v1_geog$effect - qnorm(0.975)*mod_mixed_gam_v1_geog$std_error
mod_mixed_gam_v1_geog$conf_upper <- mod_mixed_gam_v1_geog$effect + qnorm(0.975)*mod_mixed_gam_v1_geog$std_error

mod_mixed_gam_v1_geog$region <- fct_reorder(mod_mixed_gam_v1_geog$region,mod_mixed_gam_v1_geog$effect)

mod_mixed_gam_v1_geog$swingto <- case_when(mod_mixed_gam_v1_geog$effect>0 ~ "Conservative",
                              TRUE ~ "Labour")

mod_mixed_gam_v1_geog_plot1 <- ggplot(mod_mixed_gam_v1_geog,
                                     aes(x=effect, y=region,xmin=conf_lower,xmax=conf_upper,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
  scale_fill_manual(breaks = c("Conservative", "Labour"),
                    values = c("darkblue", "firebrick4")) + 
  scale_colour_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
  geom_vline(xintercept = 0, colour="red") + 
  theme_bw() + 
  labs(title = "Model: mod_mixed_gam_v1",
       subtitle = "Geographic effect") + 
  xlim(-4,2)

###
regions_contig <- cartogram_cont(region_pop,weight="pop") |> 
  mutate(fit.s.region. = mod_mixed_gam_v1_df_reg$fit.s.region.)

mod_mixed_gam_v1_geog_plot2 <- ggplot(regions_contig) + 
  geom_sf(aes(fill=fit.s.region.), lwd=0.1) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       subtitle = "Region size proportional to population") + 
  theme_bw()
###

# mod_mixed_gam_v1_geog_plot2 <- ggplot(mod_mixed_gam_v1_df_reg) + 
#   geom_sf(aes(fill=fit.s.region.), lwd=0.1) + 
#   scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
#   coord_sf(datum=NA) + 
#   labs(fill="Geographic\neffect",
#        title = "Model: mod_mixed_gam_v1") + 
#   theme_bw()

mod_mixed_gam_v1_geog_plot1 + mod_mixed_gam_v1_geog_plot2

```

Reduction in spatial autocorrelation from using the MRF spatial mixed model is no better than the simple mixed model.

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model with MRF spatial component, with fills by region for high leverage constituencies"

temp_mod_mixed_gam_v1 <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_gam_v1))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_mixed_gam_v1$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_gam_v1$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

temp_reg <- lm(wx~x,mp)

xname <- attr(mp, "xname")
ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
  geom_smooth(formula=y ~ x, method="lm") + 
  geom_hline(yintercept=mean(mp$wx), lty=2) + 
  geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
  geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
  geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
  guides(fill = "none") +
  xlab("Residuals") + 
  ylab(paste0("Spatially lagged Residuals")) +
  scale_fill_brewer(palette = "Set3") + 
  labs(title = "mod_mixed_gam_v1",
       subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
  theme(legend.position = "bottom")

```

\clearpage

### b: mod_mixed_gam_v2

#### fixed

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_gam_v2$call

mod_mixed_gam_v2_fixed <- extract_fixed(mod_mixed_gam_v2)
# 
# 
# 
# # lm coefficients
# names(mod_mixed_gam_v2_df_reg) <- str_remove(names(mod_mixed_gam_v2_df_reg), "fit.")
# temp <- mod_mixed_gam_v2_df_reg[1,c(2:5,11:14)] |> 
#   st_drop_geometry() |> 
#   t()
# temp1<-data.frame(temp[1:4,])
# temp2<-data.frame(temp[5:8,])
# temp3<-cbind(temp1,temp2) |> 
#   rownames_to_column() |> 
#   as.data.frame()
# names(temp3)<-c("term","estimate","std_error")
# temp3$conf_lower <- temp3$estimate - qnorm(0.975)*temp3$std_error
# temp3$conf_upper <- temp3$estimate + qnorm(0.975)*temp3$std_error

mod_mixed_gam_v2_fixed$swingto <- case_when(mod_mixed_gam_v2_fixed$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
mod_mixed_gam_v2_fixed$term <- str_replace(mod_mixed_gam_v2_fixed$term,"Intercept","(Intercept)")

ggplot(mod_mixed_gam_v2_fixed,aes(x=value, y=term,xmin=lower_2.5,xmax=upper_97.5,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Model: mod_mixed_gam_v2",
       subtitle = "Coefficients") + 
  xlim(-4,6)

```

#### spatial

```{r, fig.width=10,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

{ # for extracting effects with gam...
  temp <- tibble(
    degree_educated=rep(1,nrow(df_scaled_sf)),
    younger_adults=rep(1,nrow(df_scaled_sf)),
    health_not_good=rep(1,nrow(df_scaled_sf)),
    white=rep(1,nrow(df_scaled_sf)),
    no_car=rep(1,nrow(df_scaled_sf)),
    region=df_sc_region$region)
  
  
  mod_mixed_gam_v2_df <- predict(mod_mixed_gam_v2,newdata = temp,type = "terms", se.fit = TRUE) |> 
    as.data.frame() |> 
    cbind(df |> select(geometry,
                       region)) |> 
    as.data.frame() |> 
    st_as_sf()
  
  mod_mixed_gam_v2_df_reg <- regions |> 
    left_join(mod_mixed_gam_v2_df |> st_drop_geometry(), by="region") |> 
    st_drop_geometry() |> 
    unique() |> 
    left_join(regions, by="region") |> 
    st_as_sf()
}


# mrf region component
temp <- mod_mixed_gam_v2_df_reg[,c(1,6:10,15:19)] |> 
  st_drop_geometry()
temp1 <- temp[,1:6] |> 
  pivot_longer(2:6, 
               names_to = "variable",
               values_to = "effect")
temp2 <- temp[,c(1,7:11)] |> 
  pivot_longer(2:6, 
               names_to = "variable",
               values_to = "std_error")
temp3 <- cbind(temp1,temp2[,3])

temp3$variable <- str_remove(temp3$variable, "s.")

temp3$conf_lower <- temp3$effect - qnorm(0.975)*temp3$std_error
temp3$conf_upper <- temp3$effect + qnorm(0.975)*temp3$std_error

temp3$variable <- str_remove(temp3$variable, "fit.")

mod_mixed_gam_v2_plot_list <- list()
i=1
for (var in levels(df_scaled$region)){
  mmtemp <- temp3[temp3$region==levels(df_scaled$region)[i],]
  mmtemp$swingto <- case_when(mmtemp$effect>0 ~ "Conservative",
                              TRUE ~ "Labour")
  mod_mixed_gam_v2_plot_list[[i]] <- ggplot(mmtemp, aes(x=effect, y=variable,
                                              xmin=conf_lower,
                                              xmax=conf_upper, 
                                              fill=swingto,
                                              colour=swingto)) + 
    geom_errorbar(lwd=0.5, colour="black") + 
    geom_point(shape=21, size=3) + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
    theme(plot.title =element_text(size=10, face='bold'),
          plot.subtitle =element_text(size=8)) + 
    labs(x="coef effect", 
         y=NULL, 
         title = levels(df_scaled$region)[i]) + 
    guides(fill="none",
           colour="none")
  
  i= i+1
}

(plot_spacer()|plot_spacer()|mod_mixed_gam_v2_plot_list[[5]]|plot_spacer()) / 
  (plot_spacer()|mod_mixed_gam_v2_plot_list[[4]]|mod_mixed_gam_v2_plot_list[[6]]|mod_mixed_gam_v2_plot_list[[11]]|plot_spacer()) / 
  (mod_mixed_gam_v2_plot_list[[9]]|mod_mixed_gam_v2_plot_list[[10]]|mod_mixed_gam_v2_plot_list[[2]]|mod_mixed_gam_v2_plot_list[[1]]) /
  (plot_spacer()|mod_mixed_gam_v2_plot_list[[8]]|mod_mixed_gam_v2_plot_list[[3]]|mod_mixed_gam_v2_plot_list[[7]]) +
  plot_annotation(
    title = "Model: mod_mixed_gam_v2",
    subtitle = "Random intercepts and coefficients",
    theme = theme(plot.title = element_text(size = 16))
  )

```

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

# map polygons with equal numbers of voters per pixel
regions_dorling <- cartogram_dorling(region_pop,weight="pop") |> 
  left_join(temp3, by=c("region"="region")) |> 
  mutate(sig_estimate = case_when(conf_lower <0 & conf_upper<0 ~ effect,
                                  conf_lower >0 & conf_upper>0 ~ effect,
                                  TRUE ~ 0))

dorl_mod_mixed_gam_v2 <- ggplot() + 
  geom_sf(data=regions_dorling,aes(fill=sig_estimate),colour="black") + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint=0) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_gam_v2",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~variable, ncol = 5)

dorl_mod_mixed_gam_v2

# map polygons with equal numbers of voters per pixel
counties_dorling <- cartogram_dorling(region_pop,weight="pop") |> 
  left_join(temp3, by=c("region"="region")) |> 
  mutate(signifigant = case_when(conf_lower <0 & conf_upper<0 ~ "yes",
                                  conf_lower >0 & conf_upper>0 ~ "yes",
                                  TRUE ~ "no"))

dorl_mod_mixed_gam_v2_p2 <- ggplot() + 
  geom_sf(data=counties_dorling,aes(fill=effect,colour=signifigant), linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint=0) + 
  scale_colour_manual(values = c("gray90","black")) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_gam_v2",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~variable, ncol = 5)

dorl_mod_mixed_gam_v2_p2

```

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed_gam_v2, with fills by region for high leverage constituencies"

temp_mod_mixed_gam_v2 <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_gam_v2))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_mixed_gam_v2$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_gam_v2$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

temp_reg <- lm(wx~x,mp)

xname <- attr(mp, "xname")
ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
  geom_smooth(formula=y ~ x, method="lm") + 
  geom_hline(yintercept=mean(mp$wx), lty=2) + 
  geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
  geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
  geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
  guides(fill = "none") +
  xlab("Residuals") + 
  ylab(paste0("Spatially lagged Residuals")) +
  scale_fill_brewer(palette = "Set3") + 
  labs(title = "mod_mixed_gam_v2",
       subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
  theme(legend.position = "bottom")

```

\clearpage

## Comparison of mixed and spatial mixed v1

Using mixed: `mod_mixed_lmer`

Using spatial: `mod_mixed_gam_v1`

Both sets of coefficients and associated error bars are very similar.

The `lmer` model, which has no spatial effects (other than the inclusion of region as a group effect), has narrower error bars.

Will use the more conservative `mod_mixed_gam_v1` whose wider confidence intervals reflect a slightly greater uncertainty due to a small degree of spatial autocorrelation.

```{r, fig.width=12,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_lmer_rand <- broom.mixed::tidy(mod_mixed_lmer, effects="ran_vals", conf.int=TRUE) |> 
  filter(term != "(Intercept)") |> 
  select(-effect,-group) |> 
  rename(effect = term,
         lower_2.5 = conf.low,
         upper_97.5 = conf.high,
         value = estimate,
         group = level,
         se = std.error)
mod_mixed_lmer_rand$model = rep("mod_mixed_lmer",nrow(mod_mixed_lmer_rand))

mod_mixed_lmer_rand$effect <- fct_reorder(mod_mixed_lmer_rand$effect, mod_mixed_lmer_rand$value)
mod_mixed_lmer_rand$swingto <- case_when(mod_mixed_lmer_rand$value>0 ~ "Conservative",
                              TRUE ~ "Labour")

mod_mixed_gam_v1_random <- extract_ranef(mod_mixed_gam_v1) |> 
  select(-group_var) |> 
  mutate(model = rep("mod_mixed_gam_v1",nrow(mod_mixed_gam_v1_random)))

mod_mixed_gam_v1_random$effect <- fct_reorder(mod_mixed_gam_v1_random$effect, mod_mixed_gam_v1_random$value)
mod_mixed_gam_v1_random$swingto <- case_when(mod_mixed_gam_v1_random$value>0 ~ "Conservative",
                              TRUE ~ "Labour")

two_mods <- rbind(mod_mixed_lmer_rand,mod_mixed_gam_v1_random)

ggplot(two_mods, aes(x=value, y=group,
                     xmin=lower_2.5,
                     xmax=upper_97.5, 
                     fill=model,
                     colour=model,
                     group=model)) +
  geom_errorbar(lwd=0.8,position = position_dodge(width=0.8)) + 
  geom_point(shape=21, size=1.5,position = position_dodge(width=0.8)) + 
  geom_vline(xintercept = 0, colour="red") + 
  # scale_colour_manual(values = c("darkblue","#DE8E89")) + 
  # scale_fill_manual(values = c("darkblue","#DE8E89")) + 
  scale_colour_manual(values = c("darkblue","saddlebrown")) + 
  scale_fill_manual(values = c("darkblue","saddlebrown")) + 
  facet_grid(~effect) + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(override.aes = list(size = 4))) + 
  labs(x="coef effect", 
       y=NULL, 
       title = "Comparison of random effects",
       subtitle = "mod_mixed_lmer and mod_mixed_gam_v1") + 
  guides(colour="none")

```

## Comparison of mixed and spatial mixed v2

Using mixed: `mod_mixed_lmer`

Using spatial: `mod_mixed_gam_v2`

```{r, fig.width=12,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_lmer_rand <- broom.mixed::tidy(mod_mixed_lmer, effects="ran_vals", conf.int=TRUE) |> 
  filter(term != "(Intercept)") |> 
  select(-effect,-group) |> 
  rename(effect = term,
         lower_2.5 = conf.low,
         upper_97.5 = conf.high,
         value = estimate,
         group = level,
         se = std.error)
mod_mixed_lmer_rand$model = rep("mod_mixed_lmer",nrow(mod_mixed_lmer_rand))

mod_mixed_lmer_rand$effect <- fct_reorder(mod_mixed_lmer_rand$effect, mod_mixed_lmer_rand$value)
mod_mixed_lmer_rand$swingto <- case_when(mod_mixed_lmer_rand$value>0 ~ "Conservative",
                              TRUE ~ "Labour")

# bring back gam_v2 dataframes from before...
temp <- mod_mixed_gam_v2_df_reg[,c(1,6:10,15:19)] |> 
  st_drop_geometry()
temp1 <- temp[,1:6] |> 
  pivot_longer(2:6, 
               names_to = "variable",
               values_to = "effect")
temp2 <- temp[,c(1,7:11)] |> 
  pivot_longer(2:6, 
               names_to = "variable",
               values_to = "std_error")
temp3 <- cbind(temp1,temp2[,3])

temp3$variable <- str_remove(temp3$variable, "s.")

temp3$conf_lower <- temp3$effect - qnorm(0.975)*temp3$std_error
temp3$conf_upper <- temp3$effect + qnorm(0.975)*temp3$std_error

temp3$variable <- str_remove(temp3$variable, "fit.")

temp4 <- temp3 |> 
  rename(group = region,
         value = effect,
         effect = variable,
         se = std_error,
         lower_2.5 = conf_lower,
         upper_97.5 = conf_upper) |> 
  filter(effect!="region.")
temp4$model <- rep("mod_mixed_gam_v2",nrow(temp4))
temp4$swingto <- case_when(temp4$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
temp4$effect <- str_remove(temp4$effect, "region..")

two_mods2 <- rbind(mod_mixed_lmer_rand,temp4)

ggplot(two_mods2, aes(x=value, y=group,
                     xmin=lower_2.5,
                     xmax=upper_97.5, 
                     fill=model,
                     colour=model,
                     group=model)) +
  geom_errorbar(lwd=0.8,position = position_dodge(width=0.8)) + 
  geom_point(shape=21, size=1.5,position = position_dodge(width=0.8)) + 
  geom_vline(xintercept = 0, colour="red") + 
  # scale_colour_manual(values = c("darkblue","#DE8E89")) + 
  # scale_fill_manual(values = c("darkblue","#DE8E89")) + 
  scale_colour_manual(values = c("darkblue","saddlebrown")) + 
  scale_fill_manual(values = c("darkblue","saddlebrown")) + 
  facet_grid(~effect) + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(override.aes = list(size = 4))) + 
  labs(x="coef effect", 
       y=NULL, 
       title = "Comparison of random effects",
       subtitle = "mod_mixed_lmer and mod_mixed_gam_v2") + 
  guides(colour="none")

```


The three models together:

```{r, fig.width=12,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

three_mods <- rbind(two_mods,temp4)

ggplot(three_mods, aes(x=value, y=group,
                     xmin=lower_2.5,
                     xmax=upper_97.5, 
                     fill=model,
                     colour=model,
                     group=model)) +
  geom_errorbar(lwd=0.8,position = position_dodge(width=0.8)) + 
  geom_point(shape=21, size=1.5,position = position_dodge(width=0.8)) + 
  geom_vline(xintercept = 0, colour="red") + 
  # scale_colour_manual(values = c("darkblue","#DE8E89")) + 
  # scale_fill_manual(values = c("darkblue","#DE8E89")) + 
  scale_colour_manual(values = c("darkgreen","darkblue","saddlebrown")) + 
  scale_fill_manual(values = c("darkgreen","darkblue","saddlebrown")) + 
  facet_grid(~effect) + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(override.aes = list(size = 4))) + 
  labs(x="coef effect", 
       y=NULL, 
       title = "Comparison of random effects",
       subtitle = "mod_mixed_lmer, mod_mixed_gam_v1, and mod_mixed_gam_v2") + 
  guides(colour="none")



```

## Likelihood ratio tests

LR tests:
 
If I am interpreting correctly, the likelihood ratio tests seem to show that:
 
Mixed models are better than simple linear models (as expected): comparing mod_lm (re-expressed as mod_gls), to mod_mixed_nlme.
 
The model which also allows spatial relationships within regions (mod_nlme_corExp) is better than mod_mixed_nlme (and I suppose the other two identical but differently expressed models lmer and gam).
 
The mod_mixed_gam_v1 with contiguity relationship between regions is also better than the three basic mixed model version.
 
However, Im not sure if I can perform a LRT between mod_nlme_corExp and mod_mixed_gam_v1 or mod_mixed_gam_v2 to decide which is better.

```{r}

###

lm_mrf_lrt_df <- anova(mod_lm,mod_lm_mrf) |> 
  mutate(model = c("mod_lm","mod_lm_mrf")) |> 
  select(model, everything())

kbl(lm_mrf_lrt_df, caption="LM/MRF models: Likelihood ratio test p-values") |> 
  kable_classic(full_width = F, html_font = "Cambria")

###

# express mod_lm as a gls from nlme package for anova comparison

mod_gls <- gls(con_swing ~
               degree_educated +
               younger_adults +
               health_not_good +
               white,
             data=df_scaled_sf)

gls_lrt_df <- anova(mod_gls,mod_mixed_nlme)[,-1] # which is the same model as mod_mix_lmer and mod_mixed_gam

kbl(gls_lrt_df, caption="GLS models: Likelihood ratio test p-values") |> 
  kable_classic(full_width = F, html_font = "Cambria")

###

nlme_list <- list()

nlme_list[[1]] <- mod_mixed_nlme
nlme_list[[2]] <- mod_nlme_corExp
nlme_list[[3]] <- mod_nlme_corLin
nlme_list[[4]] <- mod_nlme_corGaus

nlme_lrt_df <- data.frame(
  model = c("mod_mixed_nlme","mod_nlme_corExp","mod_nlme_corLin","mod_nlme_corGaus"),
  mod_mixed_nlme = c(
    "-",
    round((anova(nlme_list[[1]],nlme_list[[2]]))$`p-value`[2],3),
    round((anova(nlme_list[[1]],nlme_list[[3]]))$`p-value`[2],3),
    round((anova(nlme_list[[1]],nlme_list[[4]]))$`p-value`[2],3)
  )
    )

kbl(nlme_lrt_df, caption="NLME models: Likelihood ratio test p-values") |> 
  kable_classic(full_width = F, html_font = "Cambria")

###

gam_list <- list()

gam_list[[1]] <- mod_mixed_gam
gam_list[[2]] <- mod_mixed_gam_v1
gam_list[[3]] <- mod_mixed_gam_v2

gam_lrt_df <- data.frame(
  model = c("mod_mixed_gam","mod_mixed_gam_v1","mod_mixed_gam_v2"),
  mod_mixed_gam = c(
    "-",
    round((anova(gam_list[[1]],gam_list[[2]],test = "Chisq"))$`Pr(>Chi)`[2],3),
    round((anova(gam_list[[1]],gam_list[[3]],test = "Chisq"))$`Pr(>Chi)`[2],3)
  ),
  mod_mixed_gam_v1 = c(
    "-",
    "-",
    round((anova(gam_list[[2]],gam_list[[3]],test = "Chisq"))$`Pr(>Chi)`[2],3)
  ),
  mod_mixed_gam_v2 = c(
    "-",
    "-",
    "-"
  )
)

kbl(gam_lrt_df, caption="GAM models: Likelihood ratio test p-values using anova() function") |> 
  kable_classic(full_width = F, html_font = "Cambria")

###
library(lmtest)
lrt_1 <- lrtest(mod_mixed_gam,mod_mixed_gam_v1)
lrt_2 <- lrtest(mod_mixed_gam,mod_mixed_gam_v2)
lrt_3 <- lrtest(mod_mixed_gam_v1,mod_mixed_gam_v2)

gam_lrt_df2 <- data.frame(
  model = c("mod_mixed_gam","mod_mixed_gam_v1","mod_mixed_gam_v2"),
  mod_mixed_gam = c(
    "-",
    round(lrt_1$`Pr(>Chisq)`[2],3),
    round(lrt_2$`Pr(>Chisq)`[2],3)
  ),
  mod_mixed_gam_v1 = c(
    "-",
    "-",
    round(lrt_3$`Pr(>Chisq)`[2],3)
  ),
  mod_mixed_gam_v2 = c(
    "-",
    "-",
    "-"
  )
)

kbl(gam_lrt_df2, caption="GAM models: Likelihood ratio test p-values using lrt() function") |> 
  kable_classic(full_width = F, html_font = "Cambria")

```



## Moran's Plot for nlme_CorExp

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

temp_mod_mixed_nlme <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = as.numeric(resid(mod_nlme_corExp)))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_mixed_nlme$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_nlme$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

temp_reg <- lm(wx~x,mp)

xname <- attr(mp, "xname")
ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
  geom_smooth(formula=y ~ x, method="lm") + 
  geom_hline(yintercept=mean(mp$wx), lty=2) + 
  geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
  geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
  geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
  guides(fill = "none") +
  xlab("Residuals") + 
  ylab(paste0("Spatially lagged Residuals")) +
  scale_fill_brewer(palette = "Set3") + 
  labs(title = "mod_nlme_corExp",
       subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
  theme(legend.position = "bottom")

```

## Tracking the removal of spatial autocorrelation with different models

Individual Moran's plots of residuals by region for different models

### mod_lm

```{r, fig.width=12, fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

temp_mod_lm <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = as.numeric(resid(mod_lm)))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_lm$resids, df_wts, zero.policy = TRUE, labels = temp_mod_lm$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

moranplot_list <- list()

tab_mod_lm <- data.frame(
  region = regions$region,
  slope = rep(NA,nrow(regions)),
  pval = rep(NA,nrow(regions)),
  model = rep("mod_lm",nrow(regions))
)

for (i in 1:nrow(regions)){
  mp_reg <- mp |> filter(region==regions$region[i])
  temp_reg <- lm(wx~x,mp_reg)
  summary_temp_reg <- summary(temp_reg)
  
  xname <- attr(mp_reg, "xname")
  moranplot_list[[i]] <- ggplot(mp_reg, aes(x=x, y=wx)) + geom_point(shape=1) + 
    geom_smooth(formula=y ~ x, method="lm") + 
    geom_hline(yintercept=mean(mp_reg$wx), lty=2) + 
    geom_vline(xintercept=mean(mp_reg$x), lty=2) + theme_minimal() + 
    #geom_point(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx), shape=9) +
    #geom_label(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
    guides(fill = "none") +
    xlim(-5,5) + 
    ylim(-5,5) +
    xlab("Residuals") + 
    ylab(paste0("Spatially lagged Residuals")) +
    scale_fill_brewer(palette = "Set3") + 
    labs(title = regions$region[i],
         subtitle = paste0(
           "Slope = ",round(summary_temp_reg$coefficients[2,1],2),
           " , p-value = ",round(summary_temp_reg$coefficients[2,4],2))) + 
    theme(legend.position = "bottom")
  
  tab_mod_lm$slope[i] <- round(summary_temp_reg$coefficients[2,1],2)
  tab_mod_lm$pval[i] <- round(summary_temp_reg$coefficients[2,4],2)
}

ggarrange(moranplot_list[[1]],moranplot_list[[2]],moranplot_list[[3]],
          moranplot_list[[4]],moranplot_list[[5]],moranplot_list[[6]],
          moranplot_list[[7]],moranplot_list[[8]],moranplot_list[[9]],
          moranplot_list[[10]],moranplot_list[[11]],nrow=3,ncol = 4)

```


### mod_lm_mrf

```{r, fig.width=12, fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

temp_mod_lm_mrf <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = as.numeric(resid(mod_lm_mrf)))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_lm_mrf$resids, df_wts, zero.policy = TRUE, labels = temp_mod_lm_mrf$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

moranplot_list <- list()

tab_mod_lm_mrf <- data.frame(
  region = regions$region,
  slope = rep(NA,nrow(regions)),
  pval = rep(NA,nrow(regions)),
  model = rep("mod_lm_mrf",nrow(regions))
)

for (i in 1:nrow(regions)){
  mp_reg <- mp |> filter(region==regions$region[i])
  temp_reg <- lm(wx~x,mp_reg)
  summary_temp_reg <- summary(temp_reg)
  
  xname <- attr(mp_reg, "xname")
  moranplot_list[[i]] <- ggplot(mp_reg, aes(x=x, y=wx)) + geom_point(shape=1) + 
    geom_smooth(formula=y ~ x, method="lm") + 
    geom_hline(yintercept=mean(mp_reg$wx), lty=2) + 
    geom_vline(xintercept=mean(mp_reg$x), lty=2) + theme_minimal() + 
    #geom_point(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx), shape=9) +
    #geom_label(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
    guides(fill = "none") +
    xlim(-5,5) + 
    ylim(-5,5) +
    xlab("Residuals") + 
    ylab(paste0("Spatially lagged Residuals")) +
    scale_fill_brewer(palette = "Set3") + 
    labs(title = regions$region[i],
         subtitle = paste0(
           "Slope = ",round(summary_temp_reg$coefficients[2,1],2),
           " , p-value = ",round(summary_temp_reg$coefficients[2,4],2))) + 
    theme(legend.position = "bottom")
  
  tab_mod_lm_mrf$slope[i] <- round(summary_temp_reg$coefficients[2,1],2)
  tab_mod_lm_mrf$pval[i] <- round(summary_temp_reg$coefficients[2,4],2)
}

ggarrange(moranplot_list[[1]],moranplot_list[[2]],moranplot_list[[3]],
          moranplot_list[[4]],moranplot_list[[5]],moranplot_list[[6]],
          moranplot_list[[7]],moranplot_list[[8]],moranplot_list[[9]],
          moranplot_list[[10]],moranplot_list[[11]],nrow=3,ncol = 4)

```



### nlme_corExp

```{r, fig.width=12, fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

temp_mod_mixed_nlme_corExp <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = as.numeric(resid(mod_nlme_corExp)))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_mixed_nlme_corExp$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_nlme_corExp$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

moranplot_list <- list()

tab_mod_mixed_nlme_corExp <- data.frame(
  region = regions$region,
  slope = rep(NA,nrow(regions)),
  pval = rep(NA,nrow(regions)),
  model = rep("mod_mixed_nlme_corExp",nrow(regions))
)

for (i in 1:nrow(regions)){
  mp_reg <- mp |> filter(region==regions$region[i])
  temp_reg <- lm(wx~x,mp_reg)
  summary_temp_reg <- summary(temp_reg)
  
  xname <- attr(mp_reg, "xname")
  moranplot_list[[i]] <- ggplot(mp_reg, aes(x=x, y=wx)) + geom_point(shape=1) + 
    geom_smooth(formula=y ~ x, method="lm") + 
    geom_hline(yintercept=mean(mp_reg$wx), lty=2) + 
    geom_vline(xintercept=mean(mp_reg$x), lty=2) + theme_minimal() + 
    #geom_point(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx), shape=9) +
    #geom_label(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
    guides(fill = "none") +
    xlim(-5,5) + 
    ylim(-5,5) +
    xlab("Residuals") + 
    ylab(paste0("Spatially lagged Residuals")) +
    scale_fill_brewer(palette = "Set3") + 
    labs(title = regions$region[i],
         subtitle = paste0(
           "Slope = ",round(summary_temp_reg$coefficients[2,1],2),
           " , p-value = ",round(summary_temp_reg$coefficients[2,4],2))) + 
    theme(legend.position = "bottom")
  
  tab_mod_mixed_nlme_corExp$slope[i] <- round(summary_temp_reg$coefficients[2,1],2)
  tab_mod_mixed_nlme_corExp$pval[i] <- round(summary_temp_reg$coefficients[2,4],2)
}

ggarrange(moranplot_list[[1]],moranplot_list[[2]],moranplot_list[[3]],
          moranplot_list[[4]],moranplot_list[[5]],moranplot_list[[6]],
          moranplot_list[[7]],moranplot_list[[8]],moranplot_list[[9]],
          moranplot_list[[10]],moranplot_list[[11]],nrow=3,ncol = 4)

```



### mod_mixed_lmer

```{r, fig.width=12, fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

temp_mod_mixed_lmer <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = as.numeric(resid(mod_mixed_lmer)))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_mixed_lmer$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_lmer$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

moranplot_list <- list()

tab_mod_mixed_lmer <- data.frame(
  region = regions$region,
  slope = rep(NA,nrow(regions)),
  pval = rep(NA,nrow(regions)),
  model = rep("mod_mixed_lmer",nrow(regions))
)

for (i in 1:nrow(regions)){
  mp_reg <- mp |> filter(region==regions$region[i])
  temp_reg <- lm(wx~x,mp_reg)
  summary_temp_reg <- summary(temp_reg)
  
  xname <- attr(mp_reg, "xname")
  moranplot_list[[i]] <- ggplot(mp_reg, aes(x=x, y=wx)) + geom_point(shape=1) + 
    geom_smooth(formula=y ~ x, method="lm") + 
    geom_hline(yintercept=mean(mp_reg$wx), lty=2) + 
    geom_vline(xintercept=mean(mp_reg$x), lty=2) + theme_minimal() + 
    #geom_point(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx), shape=9) +
    #geom_label(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
    guides(fill = "none") +
    xlim(-5,5) + 
    ylim(-5,5) +
    xlab("Residuals") + 
    ylab(paste0("Spatially lagged Residuals")) +
    scale_fill_brewer(palette = "Set3") + 
    labs(title = regions$region[i],
         subtitle = paste0(
           "Slope = ",round(summary_temp_reg$coefficients[2,1],2),
           " , p-value = ",round(summary_temp_reg$coefficients[2,4],2))) + 
    theme(legend.position = "bottom")
  
  tab_mod_mixed_lmer$slope[i] <- round(summary_temp_reg$coefficients[2,1],2)
  tab_mod_mixed_lmer$pval[i] <- round(summary_temp_reg$coefficients[2,4],2)
}

ggarrange(moranplot_list[[1]],moranplot_list[[2]],moranplot_list[[3]],
          moranplot_list[[4]],moranplot_list[[5]],moranplot_list[[6]],
          moranplot_list[[7]],moranplot_list[[8]],moranplot_list[[9]],
          moranplot_list[[10]],moranplot_list[[11]],nrow=3,ncol = 4)

```


### mod_mixed_gam_v1

```{r, fig.width=12, fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

temp_mod_mixed_gam_v1 <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = as.numeric(resid(mod_mixed_gam_v1)))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_mixed_gam_v1$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_gam_v1$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

moranplot_list <- list()

tab_mod_mixed_gam_v1 <- data.frame(
  region = regions$region,
  slope = rep(NA,nrow(regions)),
  pval = rep(NA,nrow(regions)),
  model = rep("mod_mixed_gam_v1",nrow(regions))
)

for (i in 1:nrow(regions)){
  mp_reg <- mp |> filter(region==regions$region[i])
  temp_reg <- lm(wx~x,mp_reg)
  summary_temp_reg <- summary(temp_reg)
  
  xname <- attr(mp_reg, "xname")
  moranplot_list[[i]] <- ggplot(mp_reg, aes(x=x, y=wx)) + 
    geom_point(shape=1) + 
    geom_smooth(formula=y ~ x, method="lm") + 
    geom_hline(yintercept=mean(mp_reg$wx), lty=2) + 
    geom_vline(xintercept=mean(mp_reg$x), lty=2) + theme_minimal() + 
    #geom_point(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx), shape=9) +
    #geom_label(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
    guides(fill = "none") +
    xlim(-5,5) + 
    ylim(-5,5) +
    xlab("Residuals") + 
    ylab(paste0("Spatially lagged Residuals")) +
    scale_fill_brewer(palette = "Set3") + 
    labs(title = regions$region[i],
         subtitle = paste0(
           "Slope = ",round(summary_temp_reg$coefficients[2,1],2),
           " , p-value = ",round(summary_temp_reg$coefficients[2,4],2))) + 
    theme(legend.position = "bottom")
  
  tab_mod_mixed_gam_v1$slope[i] <- round(summary_temp_reg$coefficients[2,1],2)
  tab_mod_mixed_gam_v1$pval[i] <- round(summary_temp_reg$coefficients[2,4],2)
}

ggarrange(moranplot_list[[1]],moranplot_list[[2]],moranplot_list[[3]],
          moranplot_list[[4]],moranplot_list[[5]],moranplot_list[[6]],
          moranplot_list[[7]],moranplot_list[[8]],moranplot_list[[9]],
          moranplot_list[[10]],moranplot_list[[11]],nrow=3,ncol = 4)

```


### mod_mixed_gam_v2

```{r, fig.width=12, fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

temp_mod_mixed_gam_v2 <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = as.numeric(resid(mod_mixed_gam_v2)))

df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

mp <- moran.plot(temp_mod_mixed_gam_v2$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_gam_v2$constituency_name, plot=FALSE) |> 
  mutate(region=df$region)

moranplot_list <- list()

tab_mod_mixed_gam_v2 <- data.frame(
  region = regions$region,
  slope = rep(NA,nrow(regions)),
  pval = rep(NA,nrow(regions)),
  model = rep("mod_mixed_gam_v2",nrow(regions))
)

for (i in 1:nrow(regions)){
  mp_reg <- mp |> filter(region==regions$region[i])
  temp_reg <- lm(wx~x,mp_reg)
  summary_temp_reg <- summary(temp_reg)
  
  xname <- attr(mp_reg, "xname")
  moranplot_list[[i]] <- ggplot(mp_reg, aes(x=x, y=wx)) + 
    geom_point(shape=1) + 
    geom_smooth(formula=y ~ x, method="lm") + 
    geom_hline(yintercept=mean(mp_reg$wx), lty=2) + 
    geom_vline(xintercept=mean(mp_reg$x), lty=2) + theme_minimal() + 
    #geom_point(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx), shape=9) +
    #geom_label(data=mp_reg[mp_reg$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
    guides(fill = "none") +
    xlim(-5,5) + 
    ylim(-5,5) +
    xlab("Residuals") + 
    ylab(paste0("Spatially lagged Residuals")) +
    scale_fill_brewer(palette = "Set3") + 
    labs(title = regions$region[i],
         subtitle = paste0(
           "Slope = ",round(summary_temp_reg$coefficients[2,1],2),
           " , p-value = ",round(summary_temp_reg$coefficients[2,4],2))) + 
    theme(legend.position = "bottom")
  
  tab_mod_mixed_gam_v2$slope[i] <- round(summary_temp_reg$coefficients[2,1],2)
  tab_mod_mixed_gam_v2$pval[i] <- round(summary_temp_reg$coefficients[2,4],2)
}

ggarrange(moranplot_list[[1]],moranplot_list[[2]],moranplot_list[[3]],
          moranplot_list[[4]],moranplot_list[[5]],moranplot_list[[6]],
          moranplot_list[[7]],moranplot_list[[8]],moranplot_list[[9]],
          moranplot_list[[10]],moranplot_list[[11]],nrow=3,ncol = 4)

```


### Together in one image

#### Morans I (spatial autocorrelation of residuals):
 
mod_nlme_corExp does not remove as much of this as the models without this within-region feature.
 
When looking at the morans I plots constructed by region for each model, mod_nlme_corExp leaves significant autocorrelation in four regions, while the mixed models and v1 and v2 only leave it in three regions.

```{r, fig.width=10, fig.height=6}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

moran_tab <- rbind(tab_mod_lm,
                   tab_mod_lm_mrf,
                   tab_mod_mixed_nlme_corExp,
                   tab_mod_mixed_lmer,
                   tab_mod_mixed_gam_v1,
                   tab_mod_mixed_gam_v2
) |> 
  mutate(sig_slope = case_when(pval <= 0.05 ~ slope,
                               TRUE ~ 0),
         model = factor(model,levels = c("mod_lm",
                                         "mod_lm_mrf",
                                         "mod_mixed_nlme_corExp",
                                         "mod_mixed_lmer",
                                         "mod_mixed_gam_v1",
                                         "mod_mixed_gam_v2")))

ggplot(moran_tab) + 
  geom_abline(aes(intercept = 0, 
                  slope = sig_slope,
                  group = model,
                  colour = region),
              size=0.3) + 
  scale_color_paletteer_d(palette = "ggthemes::stata_s1color") + 
  geom_hline(yintercept = 0, size=1) + 
  geom_vline(xintercept = 0, size=1) + 
  xlim(-5,5) + 
  ylim(-5,5) + 
  xlab("Residuals") + 
  ylab(paste0("Spatially lagged Residuals")) +
  theme_bw() + 
  facet_wrap(~model) + 
  labs(title = "Moran's I by region at 0.05 significance level")

```

#### Spatial effects on coefficients

```{r, fig.width=10, fig.height=6}

dorl_mod_mixed_lmer
dorl_mod_mixed_gam_v1
dorl_mod_mixed_gam_v2

dorl_mod_mixed_lmer_p2
dorl_mod_mixed_gam_v1_p2
dorl_mod_mixed_gam_v2_p2

```









