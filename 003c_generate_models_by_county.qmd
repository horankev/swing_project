---
title: "Model generation with county grouping"
author: "Kevin Horan"
execute: 
  echo: false
  warning: false
  message: false
  code-fold: false
  cache: false
toc: true
number-sections: false
format:
  pdf: default
  html: 
    code-fold: true
    html-math-method: katex
editor: source
---

```{r, warning=FALSE, message=FALSE}

# install.packages("devtools")
# devtools::install_github("m-clark/gammit")

packages <- c(
  "MASS",
  "tidyverse",
  "sf",
  "tmap",
  "here",
  "spdep", # areal data
  "grid",
  "GWmodel",
  "gstat",
  "kableExtra",
  "cowplot",
  "cartogram",
  "parlitools",
  "corrplot",
  "lme4",
  "mgcv",
  "ggfortify",
  "ggforce", # has geom_circle
  "gridExtra",
  "car",
  "rgeoda", # for LISA
  "ggpubr",
  "ggrepel",
  "ggpointdensity",
  "ggalt", # for geom_encircle
  "ggsflabel", # has repel labels for sf
  "viridis",
  "spatialreg",
  "rgdal",
  "rgeos",
  "randomForest",
  "broom",
  "patchwork",
  "nlme",
  "paletteer", # easy access to many palettes (eg >10 discrete colours...)
  "broom.mixed", # extract tidy output
  "merTools", # with plot functions
  "DiagrammeR", # mermaid
  "gammit" # for pulling out ran and fixed effs
  )


# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))

options(kableExtra.latex.load_packages = TRUE)

tmap_mode("plot")
rm(list=ls())

```

```{r}

# avoid conflict with dplyr and MASS::select
select <- dplyr::select

set.seed(123)

```

## By county, not region 

Changing the level from region to `county`. This should make the MRF more meaningful give it a better opportunity to smooth appropriately. It shows different relative AIC scores and Moran's I to what occurs under the same models but by `region`.

```{r, warning=FALSE, message=FALSE}

df <- readRDS("/Users/kevinhoran/Library/CloudStorage/OneDrive-MaynoothUniversity/swing_project/data/df.rds") |> 
  mutate(degree_educated = degree,
         professionals = industry_professional,
         younger_adults = age_18_to_19 + age_20_to_24 + age_25_to_29 + age_30_to_44,
         english_speaking = english_all,
         single_ethnicity_household = 100 - ethnicity_mixed,
         health_not_good = health_fair + health_bad + health_very_bad,
         deprived = deprived_1 + deprived_2 + deprived_3,
         white = ethnicity_white,
         christian = christian,
         own_home = house_owned,
         no_car = cars_none,
         density = density,
         county = as.character(county),
         county = factor(county)) |> 
  st_as_sf() |> 
  st_transform(crs=27700)

hex <- west_hex_map
df_hex <- df |> 
  st_drop_geometry() |> 
  inner_join(hex |> select(-"constituency_name"), #  no letter case confusion
             by = c("ons_const_id"="gss_code")) |> 
  st_as_sf()

hex_regions <- df_hex |> 
  group_by(region) |> 
  summarise() |> 
  st_as_sf()

regions <- df |> group_by(region) |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)

counties <- df |> group_by(county) |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)

vardf <- data.frame(variable = c("degree_educated",
               "professionals",
               "younger_adults",
               "english_speaking",
               "single_ethnicity_household",
               "deprived",
               "white",
               "christian",
               "own_home",
               "no_car"))

var_justification <- data.frame(
  variable = c("degree_educated",
               "professionals",
               "younger_adults",
               "english_speaking",
               "single_ethnicity_household",
               "deprived",
               "white",
               "christian",
               "own_home",
               "no_car"),
  justification = c(rep("post-industrial / knowledge economy",3),
                    rep("diversity / values / outcomes",5),
                    rep("metropolitan / 'big-city'",2)),
  jcolour = c(rep("navyblue",3),
                    rep("firebrick4",5),
                    rep("darkgreen",2))
)


# scale the variables to better judge relative strength of effects
df_scaled <- df |> 
  st_drop_geometry() |> 
  select(degree_educated,
    professionals,
    younger_adults,
    english_speaking,
    single_ethnicity_household,
    health_not_good,
    white,
    christian,
    own_home,
    no_car) |> 
  scale() |> 
  as.data.frame() |> 
  mutate(con_swing=df$con_swing,
         county=df$county)


df_scaled_sf <- df_scaled |> 
  mutate(constituency_name = df$constituency_name, 
         geometry = df$geometry) |> 
  st_as_sf()

```


```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

nlistcount <- counties %>% st_touches()

# make Isle of Wight and Hampshire neighbours manually
nlistcount[[26]]<-22
nlistcount[[22]]<-c(3, 13, 26, 46, 51, 53)

names(nlistcount) <- counties$county
df_sc_county <- df_scaled_sf |> 
  st_drop_geometry() |> 
  left_join(counties) |> 
  st_as_sf()

```

\clearpage

```{r}
#| code-fold: false
#| message: false
#| warning: false
#| echo: true

# not mixed models
mod_lm <- lm(con_swing ~
               degree_educated +
               younger_adults +
               health_not_good +
               white,
             data=df_scaled_sf)

mod_lm_mrf <- gam(con_swing ~
                    degree_educated +
                    younger_adults +
                    health_not_good +
                    white + 
                    s(county,bs='mrf',xt=list(nb=nlistcount)),
                  data=df_sc_county, method="REML")

###

# these three mixed models, essentially the same
mod_mixed_lmer <- 
  lmer(con_swing ~
         degree_educated +
         younger_adults +
         health_not_good +
         white +
         (1+degree_educated+younger_adults+health_not_good+white||county), 
       df_scaled, REML = TRUE)

mod_mixed_gam <- 
  gam(con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white + 
        s(county, bs="re") +
        s(degree_educated,county, bs="re") +
        s(younger_adults,county, bs="re") +
        s(health_not_good,county, bs="re") +
        s(white,county, bs="re"),
      data=df_sc_county, method="REML")

mod_mixed_nlme <- 
  lme(fixed = con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white,
      random = list(county = pdDiag(
        ~1+degree_educated+younger_adults+health_not_good+white)), 
      data=df_sc_county, method = "REML")

###

## lme4 model with correlated intercepts and slopes
mod_mixed_lmer_correl <- 
  lmer(con_swing ~
         degree_educated +
         younger_adults +
         health_not_good +
         white +
         (1+degree_educated+younger_adults+health_not_good+white|county), 
       df_scaled, REML = TRUE)

###

## nlme models with spatial autocorrelation

## first make df with X and Y coords, and crs 27700
centroids <- 
  df |> st_transform(crs=27700) |> st_centroid() |> st_coordinates() |> 
  cbind(df |> st_drop_geometry() |> select(constituency_name))
  
nlme_df <- df_sc_county |> 
  left_join(centroids, by="constituency_name") |> 
  st_drop_geometry()

mod_nlme_corGaus <- 
  lme(fixed = con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white,
      correlation = corGaus(form = ~X+Y),
      random = list(county = pdDiag(
        ~1+degree_educated+younger_adults+health_not_good+white)),
      data=nlme_df, method = "REML")

mod_nlme_corExp <- 
  lme(fixed = con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white,
      correlation = corExp(form = ~X+Y),
      random = list(county = pdDiag(
        ~1+degree_educated+younger_adults+health_not_good+white)),
      data=nlme_df, method = "REML")

mod_nlme_corLin <- 
  lme(fixed = con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white,
      correlation = corLin(form = ~X+Y),
      random = list(county = pdDiag(
        ~1+degree_educated+younger_adults+health_not_good+white)),
      data=nlme_df, method = "REML")

###

## models with spatial components

## this one, the same as the 3 identical mixed models from above, 
## except region intercept comes from mrf
mod_mixed_gam_v1 <- 
  gam(con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white + 
        s(degree_educated,county, bs="re") +
        s(younger_adults,county, bs="re") +
        s(health_not_good,county, bs="re") +
        s(white,county, bs="re") +
        s(county,bs='mrf',xt=list(nb=nlistcount)),
      data=df_sc_county, method="REML")

## here, each covariate is crossed with mrf of region
mod_mixed_gam_v2 <- 
  gam(con_swing ~
        degree_educated +
        younger_adults +
        health_not_good +
        white + 
        s(county,bs='mrf',xt=list(nb=nlistcount)) +  
        s(county,bs='mrf',xt=list(nb=nlistcount), by=degree_educated) +
        s(county,bs='mrf',xt=list(nb=nlistcount), by=younger_adults) +
        s(county,bs='mrf',xt=list(nb=nlistcount), by=health_not_good) +
        s(county,bs='mrf',xt=list(nb=nlistcount), by=white),
      data=df_sc_county, method="REML")

```

\clearpage

The following are the models constructed in the previous section. Their RMSE, AIC and mean Moran's-I are shown.

## Summary of model outputs

```{r}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

# RMSE
mod_lm_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_lm,df_sc_county))^2) / nrow(df_sc_county))
mod_lm_mrf_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_lm_mrf,df_sc_county))^2) / nrow(df_sc_county))
mod_mixed_lmer_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_mixed_lmer,df_sc_county))^2) / nrow(df_sc_county))
mod_mixed_nlme_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_mixed_nlme,df_sc_county))^2) / nrow(df_sc_county))
mod_mixed_gam_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_mixed_gam,df_sc_county))^2) / nrow(df_sc_county))
mod_mixed_lmer_correl_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_mixed_lmer_correl,df_sc_county))^2) / nrow(df_sc_county))
mod_nlme_corGaus_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_nlme_corGaus,df_sc_county))^2) / nrow(df_sc_county))
mod_nlme_corExp_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_nlme_corExp,df_sc_county))^2) / nrow(df_sc_county))
mod_nlme_corLin_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_nlme_corLin,df_sc_county))^2) / nrow(df_sc_county))
mod_mixed_gam_v1_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_mixed_gam_v1,df_sc_county))^2) / nrow(df_sc_county))
mod_mixed_gam_v2_rmse <- sqrt(sum((df_sc_county$con_swing - predict(mod_mixed_gam_v2,df_sc_county))^2) / nrow(df_sc_county))

# Moran's I
df_nb <- poly2nb(df)
df_wts <- nb2listw(df_nb, zero.policy = TRUE)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_lm) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_lm <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_lm_mrf) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_lm_mrf <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_lmer) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_lmer <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_nlme) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_nlme <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_gam) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_gam <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_lmer_correl) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_lmer_correl <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_nlme_corGaus) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_nlme_corGaus <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_nlme_corExp) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_nlme_corExp <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_nlme_corLin) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_nlme_corLin <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_gam_v1) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_gam_v1 <- round(temp_reg$coefficients[2],3)

temp_mod <- df |> 
  select(con_swing,constituency_name,constituency_name) |> 
  mutate(resids = resid(mod_mixed_gam_v2) |> as.numeric())
mp <- moran.plot(temp_mod$resids, df_wts, zero.policy = TRUE, labels = temp_mod$constituency_name, plot=FALSE) |> 
  mutate(county=df$county)
temp_reg <- lm(wx~x,mp)
m_mod_mixed_gam_v2 <- round(temp_reg$coefficients[2],3)

models_table <- data_frame(
  package = c("base","mgcv","lme4","mgcv","nlme","lme4","nlme","nlme","nlme","mgcv","mgcv"),
  model = c("mod_lm",
          "mod_lm_mrf",
          "mod_mixed_lmer",
          "mod_mixed_gam",
          "mod_mixed_nlme",
          "mod_mixed_lmer_correl",
          "mod_nlme_corGaus",
          "mod_nlme_corExp",
          "mod_nlme_corLin",
          "mod_mixed_gam_v1",
          "mod_mixed_gam_v2"),
  `Explicitly spatial` = c("No","Yes","No","No","No","No","Yes","Yes","Yes","Yes","Yes"),
  RMSE = c(mod_lm_rmse,
          mod_lm_mrf_rmse,
          mod_mixed_lmer_rmse,
          mod_mixed_gam_rmse,
          mod_mixed_nlme_rmse,
          mod_mixed_lmer_correl_rmse,
          mod_nlme_corGaus_rmse,
          mod_nlme_corExp_rmse,
          mod_nlme_corLin_rmse,
          mod_mixed_gam_v1_rmse,
          mod_mixed_gam_v2_rmse),
  `AIC (min to max)` = c(AIC(mod_lm),
          AIC(mod_lm_mrf),
          AIC(mod_mixed_lmer),
          AIC(mod_mixed_gam),
          AIC(mod_mixed_nlme),
          AIC(mod_mixed_lmer_correl),
          AIC(mod_nlme_corGaus),
          AIC(mod_nlme_corExp),
          AIC(mod_nlme_corLin),
          AIC(mod_mixed_gam_v1),
          AIC(mod_mixed_gam_v2)),
  `Morans-I` = c(m_mod_lm,
          m_mod_lm_mrf,
          m_mod_mixed_lmer,
          m_mod_mixed_gam,
          m_mod_mixed_nlme,
          m_mod_mixed_lmer_correl,
          m_mod_nlme_corGaus,
          m_mod_nlme_corExp,
          m_mod_nlme_corLin,
          m_mod_mixed_gam_v1,
          m_mod_mixed_gam_v2)) |> 
  arrange(`AIC (min to max)`)

kbl(models_table, caption="Summary of model outputs") |> 
  kable_classic(full_width = F, html_font = "Cambria")

```



```{r}

models_table2 <- models_table |> 
  mutate(framework = case_when(package == "mgcv" ~ "gam",
                                  TRUE ~ "lm"))

models_table3 <- models_table2 |> filter(package == "mgcv") |> 
  mutate(rel_AIC = `AIC (min to max)` - models_table[models_table$model=="mod_mixed_gam",]$`AIC (min to max)`)

models_table4 <- models_table2 |> filter(package != "mgcv")  |> 
  mutate(rel_AIC = round(`AIC (min to max)` - models_table[models_table$model=="mod_mixed_lmer",]$`AIC (min to max)`,3))

models_table5 <- rbind(models_table3,models_table4) |> 
  rename(AIC = `AIC (min to max)`) |> 
  arrange(rel_AIC) |> 
  data.frame()

kbl(models_table5, caption="Summary of county model outputs") |> 
  kable_classic(full_width = F, html_font = "Cambria") |> 
  row_spec(5:7, background = "#F5E4E6")

```


\clearpage

## 1: Simple linear model

Before moving to mixed models, fit a simple linear model to show why a more complicated model is required.

### mod_lm

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_lm_df <- tidy(mod_lm) |> 
  mutate(conf_lower = confint(mod_lm)[,1],
         conf_upper = confint(mod_lm)[,2])

mod_lm$call

mod_lm_df$swingto <- case_when(mod_lm_df$estimate>0 ~ "Conservative",
                              TRUE ~ "Labour")
ggplot(mod_lm_df,aes(x=estimate, y=term,xmin=conf_lower,xmax=conf_upper,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Coefficients of model: mod_lm") + 
  xlim(-4,6)

# par(mfrow=c(2,2))
# plot(mod_lm)

```

But this simple model leaves residuals which are clearly correlated to those of their neighbours, as can be seen in the following Moran's plot, which violates the assumption of independence.

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
# #| warning: false
# #| echo: false
# #| fig-cap: "Moran's scatterplot for residuals of linear model, with fills by region for high leverage constituencies"
# 
# temp_mod_lm <- df |> 
#   select(con_swing,constituency_name,constituency_name) |> 
#   mutate(resids = resid(mod_lm) |> as.numeric())
# 
# df_nb <- poly2nb(df)
# df_wts <- nb2listw(df_nb, zero.policy = TRUE)
# 
# mp <- moran.plot(temp_mod_lm$resids, df_wts, zero.policy = TRUE, labels = temp_mod_lm$constituency_name, plot=FALSE) |> 
#   mutate(county=df$county)
# 
# temp_reg <- lm(wx~x,mp)
# 
# xname <- attr(mp, "xname")
# ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
#   geom_smooth(formula=y ~ x, method="lm") + 
#   geom_hline(yintercept=mean(mp$wx), lty=2) + 
#   geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
#   geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
#   geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=county), size=1) +
#   guides(fill = "none") +
#   xlab("Residuals") + 
#   ylab(paste0("Spatially lagged Residuals")) +
#   scale_fill_brewer(palette = "Set3") + 
#   labs(title = "mod_lm",
#        subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
#   theme(legend.position = "bottom")

```

\clearpage

## 2: Linear model with mrf

### mod_lm_mrf

#### fixed

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_lm_mrf$call

mod_lm_mrf_fixed <- extract_fixed(mod_lm_mrf)

mod_lm_mrf_fixed$swingto <- case_when(mod_lm_mrf_fixed$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
mod_lm_mrf_fixed$term <- str_replace(mod_lm_mrf_fixed$term, "Intercept","(Intercept)")

ggplot(mod_lm_mrf_fixed,aes(x=value, y=term,xmin=lower_2.5,xmax=upper_97.5,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Model: mod_lm_mrf",
       subtitle = "Fixed Coefficients") + 
  xlim(-4,6)

```

#### spatial

```{r}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

{ # for extracting effects with gam...
  temp <- tibble(
    degree_educated=rep(1,nrow(df_scaled_sf)),
    younger_adults=rep(1,nrow(df_scaled_sf)),
    health_not_good=rep(1,nrow(df_scaled_sf)),
    white=rep(1,nrow(df_scaled_sf)),
    no_car=rep(1,nrow(df_scaled_sf)),
    county=df_sc_county$county)
  
  
  mod_lm_mrf_df <- predict(mod_lm_mrf,newdata = temp,type = "terms", se.fit = TRUE) |> 
    as.data.frame() |> 
    cbind(df |> select(geometry,
                       county)) |> 
    as.data.frame() |> 
    st_as_sf()
  
  mod_lm_mrf_reg <- counties |> 
    left_join(mod_lm_mrf_df |> st_drop_geometry(), by="county") |> 
    st_drop_geometry() |> 
    unique() |> 
    left_join(counties, by="county") |> 
    st_as_sf()
}


# mrf region component

temp4 <- mod_lm_mrf_reg[,c(1,6,11)]

names(temp4) <- str_remove(names(temp4),"fit.")
temp4$conf_lower <- temp4$`s.county.` - qnorm(0.975)*temp4$`se.s.county.`
temp4$conf_upper <- temp4$`s.county.` + qnorm(0.975)*temp4$`se.s.county.`
temp4$county <- fct_reorder(temp4$county,temp4$`s.county.`)

temp4$swingto <- case_when(temp4$`s.county.`>0 ~ "Conservative",
                              TRUE ~ "Labour")

```


```{r, fig.width=12, fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_lm_mrf_plot1 <- ggplot(temp4,aes(x=`s.county.`, y=county,xmin=conf_lower,xmax=conf_upper,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
  scale_fill_manual(breaks = c("Conservative", "Labour"),
                    values = c("darkblue", "firebrick4")) + 
  scale_colour_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
  geom_vline(xintercept = 0, colour="red") + 
  theme_bw() + 
  labs(title = "Model: mod_lm_mrf",
       subtitle = "Geographic effect")

mod_lm_mrf_plot1

```


```{r, fig.width=6, fig.height=6}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

# map polygons with equal numbers of voters per pixel
county_pop <- df |> 
  st_transform(27700) |> 
  group_by(county) |> 
  summarise(pop = sum(total_vote_19))
  
counties_contig <- cartogram_cont(county_pop,weight="pop") |> 
  mutate(s.county. = temp4$s.county.)
mod_lm_mrf_plot2 <- ggplot(counties_contig) + 
  geom_sf(aes(fill=s.county.), lwd=0.1) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       subtitle = "County size proportional to population") + 
  theme_bw()
###

# mod_lm_mrf_plot2 <- ggplot(temp4) + 
#   geom_sf(aes(fill=s.region.), lwd=0.1) + 
#   scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
#   coord_sf(datum=NA) + 
#   labs(fill="Geographic\neffect",
#        title = "Model: mod_lm_mrf") + 
#   theme_bw()

mod_lm_mrf_plot2

```

Spatial autocorrelation is reduced by adding MRF spatial component. It acts like a varying intercept by region.

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of linear model, with fills by region for high leverage constituencies"

# temp_mod_lm_mrf <- df |> 
#   select(con_swing,constituency_name,constituency_name) |> 
#   mutate(resids = resid(mod_lm_mrf))
# 
# df_nb <- poly2nb(df)
# df_wts <- nb2listw(df_nb, zero.policy = TRUE)
# 
# mp <- moran.plot(temp_mod_lm_mrf$resids, df_wts, zero.policy = TRUE, labels = temp_mod_lm_mrf$constituency_name, plot=FALSE) |> 
#   mutate(county=df$county)
# 
# temp_reg <- lm(wx~x,mp)
# 
# xname <- attr(mp, "xname")
# ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
#   geom_smooth(formula=y ~ x, method="lm") + 
#   geom_hline(yintercept=mean(mp$wx), lty=2) + 
#   geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
#   geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
#   geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=county), size=1) +
#   guides(fill = "none") +
#   xlab("Residuals") + 
#   ylab(paste0("Spatially lagged Residuals")) +
#   scale_fill_brewer(palette = "Set3") + 
#   labs(title = "mod_lm_mrf",
#        subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
#   theme(legend.position = "bottom")

```

```{r}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

county_pop <- df |> 
  st_transform(27700) |> 
  group_by(county) |> 
  summarise(pop = sum(population))
  
counties_contig <- cartogram_cont(county_pop,weight="pop")

```

\clearpage

## 3: Mixed model

(using `lme4` package, out of the three equivalent models created above)

### mod_mixed_lmer

#### fixed

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_lmer@call

mod_mixed_lmer_fix <- broom.mixed::tidy(mod_mixed_lmer, effects="fixed", conf.int=TRUE, conf.method = "profile")

#like_rat_pval <- as.data.frame(anova(mm2.2,mm2.1))[2,8]
mod_mixed_lmer_fix$swingto <- case_when(mod_mixed_lmer_fix$estimate>0 ~ "Conservative",
                              TRUE ~ "Labour")
ggplot(mod_mixed_lmer_fix,aes(x=estimate, y=term,xmin=conf.low,xmax=conf.high,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Model: mod_mixed_lmer",
       subtitle = "Fixed coefficients") + 
  xlim(-4,6)

```

#### random

```{r, fig.width=10,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_lmer_rand <- broom.mixed::tidy(mod_mixed_lmer, effects="ran_vals", conf.int=TRUE)

# mod_mixed_lmer_plot_list <- list()
# i=1
# for (var in levels(df_scaled$county)){
#   mmtemp <- mod_mixed_lmer_rand[mod_mixed_lmer_rand$level==levels(df_scaled$county)[i],]
#   mmtemp$swingto <- case_when(mmtemp$estimate>0 ~ "Conservative",
#                               TRUE ~ "Labour")
#   mod_mixed_lmer_plot_list[[i]] <- ggplot(mmtemp, aes(x=estimate, y=term,
#                                               xmin=conf.low,
#                                               xmax=conf.high, 
#                                               fill=swingto,
#                                               colour=swingto)) + 
#     geom_errorbar(lwd=0.5, colour="black") + 
#     geom_point(shape=21, size=3) + 
#     scale_fill_manual(breaks = c("Conservative", "Labour"),
#                       values = c("darkblue", "firebrick4")) + 
#     scale_colour_manual(breaks = c("Conservative", "Labour"),
#                         values = c("darkblue", "firebrick4")) + 
#     geom_vline(xintercept = 0, colour="red") + 
#     theme_bw() + 
#     theme(plot.title =element_text(size=10, face='bold'),
#           plot.subtitle =element_text(size=8)) + 
#     labs(x="coef effect", 
#          y=NULL, 
#          title = levels(df_scaled$county)[i]) + 
#     guides(fill="none",
#            colour="none")
#   
#   i= i+1
# }
# 
# (plot_spacer()|plot_spacer()|mod_mixed_lmer_plot_list[[5]]|plot_spacer()) / 
#   (plot_spacer()|mod_mixed_lmer_plot_list[[4]]|mod_mixed_lmer_plot_list[[6]]|mod_mixed_lmer_plot_list[[11]]|plot_spacer()) / 
#   (mod_mixed_lmer_plot_list[[9]]|mod_mixed_lmer_plot_list[[10]]|mod_mixed_lmer_plot_list[[2]]|mod_mixed_lmer_plot_list[[1]]) /
#   (plot_spacer()|mod_mixed_lmer_plot_list[[8]]|mod_mixed_lmer_plot_list[[3]]|mod_mixed_lmer_plot_list[[7]]) +
#   plot_annotation(
#     title = "Model: mod_mixed_lmer",
#     subtitle = "Random intercepts and coefficients",
#     theme = theme(plot.title = element_text(size = 16))
#   )

```

```{r, fig.width=12, fig.height=4}

# map polygons with equal numbers of voters per pixel
counties_dorling <- cartogram_dorling(county_pop,weight="pop") |> 
  left_join(mod_mixed_lmer_rand, by=c("county"="level")) |> 
  mutate(sig_estimate = case_when(conf.low <0 & conf.high<0 ~ estimate,
                                  conf.low >0 & conf.high>0 ~ estimate,
                                  TRUE ~ 0))

dorl_mod_mixed_lmer <- ggplot(counties_dorling) + 
  geom_sf(aes(fill=sig_estimate)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
  coord_sf(datum=NA) + 
  labs(fill="Random\neffects",
       title = "Model: mod_mixed_lmer",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~term, ncol = 5)

dorl_mod_mixed_lmer


# map polygons with equal numbers of voters per pixel
counties_dorling <- cartogram_dorling(county_pop,weight="pop") |> 
  left_join(mod_mixed_lmer_rand, by=c("county"="level")) |> 
  mutate(signifigant = case_when(conf.low <0 & conf.high<0 ~ "yes",
                                  conf.low >0 & conf.high>0 ~ "yes",
                                  TRUE ~ "no"))

dorl_mod_mixed_lmer_p2 <- ggplot() + 
  geom_sf(data=counties_dorling,aes(fill=estimate,colour=signifigant), linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint=0) + 
  scale_colour_manual(values = c("grey","black")) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_lmer",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~term, ncol = 5)

dorl_mod_mixed_lmer_p2



```

Spatial autocorrelation is substantially reduced by the mixed model, without adding any explicitly spatial component.

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model, with fills by region for high leverage constituencies"

# temp_mod_mixed_lmer <- df |> 
#   select(con_swing,constituency_name,constituency_name) |> 
#   mutate(resids = resid(mod_mixed_lmer))
# 
# df_nb <- poly2nb(df)
# df_wts <- nb2listw(df_nb, zero.policy = TRUE)
# 
# mp <- moran.plot(temp_mod_mixed_lmer$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_lmer$constituency_name, plot=FALSE) |> 
#   mutate(region=df$county)
# 
# temp_reg <- lm(wx~x,mp)
# 
# xname <- attr(mp, "xname")
# ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
#   geom_smooth(formula=y ~ x, method="lm") + 
#   geom_hline(yintercept=mean(mp$wx), lty=2) + 
#   geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
#   geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
#   geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=region), size=1) +
#   guides(fill = "none") +
#   xlab("Residuals") + 
#   ylab(paste0("Spatially lagged Residuals")) +
#   scale_fill_brewer(palette = "Set3") + 
#   labs(title = "mod_mixed_lmer",
#        subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
#   theme(legend.position = "bottom")

```

\clearpage

## 4: Mixed models with spatial component (x2)

### a: mod_mixed_gam_v1

#### fixed

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_gam_v1$call

mod_mixed_gam_v1_fixed <- extract_fixed(mod_mixed_gam_v1)

mod_mixed_gam_v1_fixed$term <- str_replace(mod_mixed_gam_v1_fixed$term, "Intercept","(Intercept)")
mod_mixed_gam_v1_fixed$swingto <- case_when(mod_mixed_gam_v1_fixed$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
ggplot(mod_mixed_gam_v1_fixed,aes(x=value, y=term,xmin=lower_2.5,xmax=upper_97.5,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Model: mod_mixed_gam_v1",
       subtitle = "Fixed effects") + 
  xlim(-4,6)

```

#### random

```{r, fig.width=10,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_gam_v1_random <- extract_ranef(mod_mixed_gam_v1)


# mod_mixed_gam_v1_plot_list <- list()
# i=1
# for (var in levels(df_scaled$region)){
#   mmtemp <- mod_mixed_gam_v1_random[mod_mixed_gam_v1_random$group==levels(df_scaled$county)[i],]
#   mmtemp$swingto <- case_when(mmtemp$value>0 ~ "Conservative",
#                               TRUE ~ "Labour")
#   mod_mixed_gam_v1_plot_list[[i]] <- ggplot(mmtemp, aes(x=value, y=effect,
#                                               xmin=lower_2.5,
#                                               xmax=upper_97.5, 
#                                               fill=swingto,
#                                               colour=swingto)) + 
#     geom_errorbar(lwd=0.5, colour="black") + 
#     geom_point(shape=21, size=3) + 
#     scale_fill_manual(breaks = c("Conservative", "Labour"),
#                       values = c("darkblue", "firebrick4")) + 
#     scale_colour_manual(breaks = c("Conservative", "Labour"),
#                         values = c("darkblue", "firebrick4")) + 
#     geom_vline(xintercept = 0, colour="red") + 
#     theme_bw() + 
#     theme(plot.title =element_text(size=10, face='bold'),
#           plot.subtitle =element_text(size=8)) + 
#     labs(x="coef effect", 
#          y=NULL, 
#          title = levels(df_scaled$county)[i]) + 
#     guides(fill="none",
#            colour="none")
#   
#   i= i+1
# }
# 
# (plot_spacer()|plot_spacer()|mod_mixed_gam_v1_plot_list[[5]]|plot_spacer()) / 
#   (plot_spacer()|mod_mixed_gam_v1_plot_list[[4]]|mod_mixed_gam_v1_plot_list[[6]]|mod_mixed_gam_v1_plot_list[[11]]|plot_spacer()) / 
#   (mod_mixed_gam_v1_plot_list[[9]]|mod_mixed_gam_v1_plot_list[[10]]|mod_mixed_gam_v1_plot_list[[2]]|mod_mixed_gam_v1_plot_list[[1]]) /
#   (plot_spacer()|mod_mixed_gam_v1_plot_list[[8]]|mod_mixed_gam_v1_plot_list[[3]]|mod_mixed_gam_v1_plot_list[[7]]) +
#   plot_annotation(
#     title = "Model: mod_mixed_gam_v1",
#     subtitle = "Random intercepts and coefficients",
#     theme = theme(plot.title = element_text(size = 16))
#   )

```

```{r, fig.width=12, fig.height=4}

counties_dorling <- cartogram_dorling(county_pop,weight="pop") |> 
  left_join(mod_mixed_gam_v1_random, by=c("county"="group")) |> 
  mutate(sig_estimate = case_when(lower_2.5 <0 & upper_97.5<0 ~ value,
                                  lower_2.5 >0 & upper_97.5>0 ~ value,
                                  TRUE ~ 0))

dorl_mod_mixed_gam_v1 <- ggplot(counties_dorling) + 
  geom_sf(aes(fill=sig_estimate)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_gam_v1",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~effect, ncol = 4)

dorl_mod_mixed_gam_v1

# map polygons with equal numbers of voters per pixel
counties_dorling <- cartogram_dorling(county_pop,weight="pop") |> 
  left_join(mod_mixed_gam_v1_random, by=c("county"="group")) |> 
  mutate(signifigant = case_when(lower_2.5 <0 & upper_97.5<0 ~ "yes",
                                  lower_2.5 >0 & upper_97.5>0 ~ "yes",
                                  TRUE ~ "no"))

dorl_mod_mixed_gam_v1_p2 <- ggplot() + 
  geom_sf(data=counties_dorling,aes(fill=value,colour=signifigant), linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint=0) + 
  scale_colour_manual(values = c("grey","black")) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_gam_v1",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~effect, ncol = 5)

dorl_mod_mixed_gam_v1_p2

```

#### spatial

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

{ # for extracting effects with gam...
  temp <- tibble(
    degree_educated=rep(1,nrow(df_scaled_sf)),
    younger_adults=rep(1,nrow(df_scaled_sf)),
    health_not_good=rep(1,nrow(df_scaled_sf)),
    white=rep(1,nrow(df_scaled_sf)),
    no_car=rep(1,nrow(df_scaled_sf)),
    county=df_sc_county$county)
  
  
  mod_mixed_gam_v1_df <- predict(mod_mixed_gam_v1,newdata = temp,type = "terms", se.fit = TRUE) |> 
    as.data.frame() |> 
    cbind(df |> select(geometry,
                       county)) |> 
    as.data.frame() |> 
    st_as_sf()
  
  mod_mixed_gam_v1_df_reg <- counties |> 
    left_join(mod_mixed_gam_v1_df |> st_drop_geometry(), by="county") |> 
    st_drop_geometry() |> 
    unique() |> 
    left_join(counties, by="county") |> 
    st_as_sf()
}

mod_mixed_gam_v1_geog <- mod_mixed_gam_v1_df_reg[,c(1,10,19)] |> 
  st_drop_geometry()
names(mod_mixed_gam_v1_geog) <- str_remove(names(mod_mixed_gam_v1_geog),"fit.")
names(mod_mixed_gam_v1_geog) <- c("county","effect","std_error")
mod_mixed_gam_v1_geog$conf_lower <- mod_mixed_gam_v1_geog$effect - qnorm(0.975)*mod_mixed_gam_v1_geog$std_error
mod_mixed_gam_v1_geog$conf_upper <- mod_mixed_gam_v1_geog$effect + qnorm(0.975)*mod_mixed_gam_v1_geog$std_error

mod_mixed_gam_v1_geog$county <- fct_reorder(mod_mixed_gam_v1_geog$county,mod_mixed_gam_v1_geog$effect)

mod_mixed_gam_v1_geog$swingto <- case_when(mod_mixed_gam_v1_geog$effect>0 ~ "Conservative",
                              TRUE ~ "Labour")

```



```{r, fig.width=12, fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_gam_v1_geog_plot1 <- ggplot(mod_mixed_gam_v1_geog,
                                     aes(x=effect, y=county,xmin=conf_lower,xmax=conf_upper,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
  scale_fill_manual(breaks = c("Conservative", "Labour"),
                    values = c("darkblue", "firebrick4")) + 
  scale_colour_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
  geom_vline(xintercept = 0, colour="red") + 
  theme_bw() + 
  labs(title = "Model: mod_mixed_gam_v1",
       subtitle = "Geographic effect") + 
  xlim(-4,3)

mod_mixed_gam_v1_geog_plot1

```


```{r, fig.width=6, fig.height=6}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

###
counties_contig <- cartogram_cont(county_pop,weight="pop") |> 
  mutate(fit.s.county. = mod_mixed_gam_v1_df_reg$fit.s.county.)

mod_mixed_gam_v1_geog_plot2 <- ggplot(counties_contig) + 
  geom_sf(aes(fill=fit.s.county.), lwd=0.1) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       subtitle = "County size proportional to population") + 
  theme_bw()
###

# mod_mixed_gam_v1_geog_plot2 <- ggplot(mod_mixed_gam_v1_df_reg) + 
#   geom_sf(aes(fill=fit.s.region.), lwd=0.1) + 
#   scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0) + 
#   coord_sf(datum=NA) + 
#   labs(fill="Geographic\neffect",
#        title = "Model: mod_mixed_gam_v1") + 
#   theme_bw()

mod_mixed_gam_v1_geog_plot2

```

Reduction in spatial autocorrelation from using the MRF spatial mixed model is no better than the simple mixed model.

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed model with MRF spatial component, with fills by region for high leverage constituencies"

# temp_mod_mixed_gam_v1 <- df |> 
#   select(con_swing,constituency_name,constituency_name) |> 
#   mutate(resids = resid(mod_mixed_gam_v1))
# 
# df_nb <- poly2nb(df)
# df_wts <- nb2listw(df_nb, zero.policy = TRUE)
# 
# mp <- moran.plot(temp_mod_mixed_gam_v1$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_gam_v1$constituency_name, plot=FALSE) |> 
#   mutate(county=df$county)
# 
# temp_reg <- lm(wx~x,mp)
# 
# xname <- attr(mp, "xname")
# ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
#   geom_smooth(formula=y ~ x, method="lm") + 
#   geom_hline(yintercept=mean(mp$wx), lty=2) + 
#   geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
#   geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
#   geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=county), size=1) +
#   guides(fill = "none") +
#   xlab("Residuals") + 
#   ylab(paste0("Spatially lagged Residuals")) +
#   scale_fill_brewer(palette = "Set3") + 
#   labs(title = "mod_mixed_gam_v1",
#        subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
#   theme(legend.position = "bottom")

```

\clearpage

### b: mod_mixed_gam_v2

#### fixed

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_gam_v2$call

mod_mixed_gam_v2_fixed <- extract_fixed(mod_mixed_gam_v2)
# 
# 
# 
# # lm coefficients
# names(mod_mixed_gam_v2_df_reg) <- str_remove(names(mod_mixed_gam_v2_df_reg), "fit.")
# temp <- mod_mixed_gam_v2_df_reg[1,c(2:5,11:14)] |> 
#   st_drop_geometry() |> 
#   t()
# temp1<-data.frame(temp[1:4,])
# temp2<-data.frame(temp[5:8,])
# temp3<-cbind(temp1,temp2) |> 
#   rownames_to_column() |> 
#   as.data.frame()
# names(temp3)<-c("term","estimate","std_error")
# temp3$conf_lower <- temp3$estimate - qnorm(0.975)*temp3$std_error
# temp3$conf_upper <- temp3$estimate + qnorm(0.975)*temp3$std_error

mod_mixed_gam_v2_fixed$swingto <- case_when(mod_mixed_gam_v2_fixed$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
mod_mixed_gam_v2_fixed$term <- str_replace(mod_mixed_gam_v2_fixed$term,"Intercept","(Intercept)")

ggplot(mod_mixed_gam_v2_fixed,aes(x=value, y=term,xmin=lower_2.5,xmax=upper_97.5,fill=swingto,colour=swingto)) + 
  geom_point(shape=21, size=3) + 
  geom_errorbar() + 
    scale_fill_manual(breaks = c("Conservative", "Labour"),
                      values = c("darkblue", "firebrick4")) + 
    scale_colour_manual(breaks = c("Conservative", "Labour"),
                        values = c("darkblue", "firebrick4")) + 
    geom_vline(xintercept = 0, colour="red") + 
    theme_bw() + 
  labs(title = "Model: mod_mixed_gam_v2",
       subtitle = "Coefficients") + 
  xlim(-4,6)

```

#### spatial

```{r, fig.width=10,fig.height=8}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

{ # for extracting effects with gam...
  temp <- tibble(
    degree_educated=rep(1,nrow(df_scaled_sf)),
    younger_adults=rep(1,nrow(df_scaled_sf)),
    health_not_good=rep(1,nrow(df_scaled_sf)),
    white=rep(1,nrow(df_scaled_sf)),
    no_car=rep(1,nrow(df_scaled_sf)),
    county=df_sc_county$county)
  
  
  mod_mixed_gam_v2_df <- predict(mod_mixed_gam_v2,newdata = temp,type = "terms", se.fit = TRUE) |> 
    as.data.frame() |> 
    cbind(df |> select(geometry,
                       county)) |> 
    as.data.frame() |> 
    st_as_sf()
  
  mod_mixed_gam_v2_df_reg <- counties |> 
    left_join(mod_mixed_gam_v2_df |> st_drop_geometry(), by="county") |> 
    st_drop_geometry() |> 
    unique() |> 
    left_join(counties, by="county") |> 
    st_as_sf()
}


# mrf region component
temp <- mod_mixed_gam_v2_df_reg[,c(1,6:10,15:19)] |> 
  st_drop_geometry()
temp1 <- temp[,1:6] |> 
  pivot_longer(2:6, 
               names_to = "variable",
               values_to = "effect")
temp2 <- temp[,c(1,7:11)] |> 
  pivot_longer(2:6, 
               names_to = "variable",
               values_to = "std_error")
temp3 <- cbind(temp1,temp2[,3])

temp3$variable <- str_remove(temp3$variable, "s.")

temp3$conf_lower <- temp3$effect - qnorm(0.975)*temp3$std_error
temp3$conf_upper <- temp3$effect + qnorm(0.975)*temp3$std_error

temp3$variable <- str_remove(temp3$variable, "fit.")
temp3$variable <- str_remove(temp3$variable, "county..")
temp3$variable <- str_replace(temp3$variable, "county.", "(Intercept)")

# mod_mixed_gam_v2_plot_list <- list()
# i=1
# for (var in levels(df_scaled$county)){
#   mmtemp <- temp3[temp3$county==levels(df_scaled$county)[i],]
#   mmtemp$swingto <- case_when(mmtemp$effect>0 ~ "Conservative",
#                               TRUE ~ "Labour")
#   mod_mixed_gam_v2_plot_list[[i]] <- ggplot(mmtemp, aes(x=effect, y=variable,
#                                               xmin=conf_lower,
#                                               xmax=conf_upper, 
#                                               fill=swingto,
#                                               colour=swingto)) + 
#     geom_errorbar(lwd=0.5, colour="black") + 
#     geom_point(shape=21, size=3) + 
#     scale_fill_manual(breaks = c("Conservative", "Labour"),
#                       values = c("darkblue", "firebrick4")) + 
#     scale_colour_manual(breaks = c("Conservative", "Labour"),
#                         values = c("darkblue", "firebrick4")) + 
#     geom_vline(xintercept = 0, colour="red") + 
#     theme_bw() + 
#     theme(plot.title =element_text(size=10, face='bold'),
#           plot.subtitle =element_text(size=8)) + 
#     labs(x="coef effect", 
#          y=NULL, 
#          title = levels(df_scaled$county)[i]) + 
#     guides(fill="none",
#            colour="none")
#   
#   i= i+1
# }
# 
# (plot_spacer()|plot_spacer()|mod_mixed_gam_v2_plot_list[[5]]|plot_spacer()) / 
#   (plot_spacer()|mod_mixed_gam_v2_plot_list[[4]]|mod_mixed_gam_v2_plot_list[[6]]|mod_mixed_gam_v2_plot_list[[11]]|plot_spacer()) / 
#   (mod_mixed_gam_v2_plot_list[[9]]|mod_mixed_gam_v2_plot_list[[10]]|mod_mixed_gam_v2_plot_list[[2]]|mod_mixed_gam_v2_plot_list[[1]]) /
#   (plot_spacer()|mod_mixed_gam_v2_plot_list[[8]]|mod_mixed_gam_v2_plot_list[[3]]|mod_mixed_gam_v2_plot_list[[7]]) +
#   plot_annotation(
#     title = "Model: mod_mixed_gam_v2",
#     subtitle = "Random intercepts and coefficients",
#     theme = theme(plot.title = element_text(size = 16))
#   )

```

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

# map polygons with equal numbers of voters per pixel
counties_dorling <- cartogram_dorling(county_pop,weight="pop") |> 
  left_join(temp3, by=c("county"="county")) |> 
  mutate(sig_estimate = case_when(conf_lower <0 & conf_upper<0 ~ effect,
                                  conf_lower >0 & conf_upper>0 ~ effect,
                                  TRUE ~ 0))

dorl_mod_mixed_gam_v2 <- ggplot() + 
  geom_sf(data=counties_dorling,aes(fill=sig_estimate),colour="black") + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint=0) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_gam_v2",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~variable, ncol = 5)

dorl_mod_mixed_gam_v2

# map polygons with equal numbers of voters per pixel
counties_dorling <- cartogram_dorling(county_pop,weight="pop") |> 
  left_join(temp3, by=c("county"="county")) |> 
  mutate(signifigant = case_when(conf_lower <0 & conf_upper<0 ~ "yes",
                                  conf_lower >0 & conf_upper>0 ~ "yes",
                                  TRUE ~ "no"))

dorl_mod_mixed_gam_v2_p2 <- ggplot() + 
  geom_sf(data=counties_dorling,aes(fill=effect,colour=signifigant), linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint=0) + 
  scale_colour_manual(values = c("grey","black")) + 
  coord_sf(datum=NA) + 
  labs(fill="Geographic\neffect",
       title = "Model: mod_mixed_gam_v2",
       subtitle = "Size representing population") + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  facet_wrap(~variable, ncol = 5)

dorl_mod_mixed_gam_v2_p2


```

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false
#| fig-cap: "Moran's scatterplot for residuals of mixed_gam_v2, with fills by region for high leverage constituencies"

# temp_mod_mixed_gam_v2 <- df |> 
#   select(con_swing,constituency_name,constituency_name) |> 
#   mutate(resids = resid(mod_mixed_gam_v2))
# 
# df_nb <- poly2nb(df)
# df_wts <- nb2listw(df_nb, zero.policy = TRUE)
# 
# mp <- moran.plot(temp_mod_mixed_gam_v2$resids, df_wts, zero.policy = TRUE, labels = temp_mod_mixed_gam_v2$constituency_name, plot=FALSE) |> 
#   mutate(county=df$county)
# 
# temp_reg <- lm(wx~x,mp)
# 
# xname <- attr(mp, "xname")
# ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
#   geom_smooth(formula=y ~ x, method="lm") + 
#   geom_hline(yintercept=mean(mp$wx), lty=2) + 
#   geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
#   geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
#   geom_label(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, fill=county), size=1) +
#   guides(fill = "none") +
#   xlab("Residuals") + 
#   ylab(paste0("Spatially lagged Residuals")) +
#   scale_fill_brewer(palette = "Set3") + 
#   labs(title = "mod_mixed_gam_v2",
#        subtitle = paste0("Slope = ",round(temp_reg$coefficients[2],2))) + 
#   theme(legend.position = "bottom")

```

\clearpage

## Comparison of mixed and spatial mixed v1

Using mixed: `mod_mixed_lmer`

Using spatial: `mod_mixed_gam_v1`

Both sets of coefficients and associated error bars are very similar.

The `lmer` model, which has no spatial effects (other than the inclusion of region as a group effect), has narrower error bars.

Will use the more conservative `mod_mixed_gam_v1` whose wider confidence intervals reflect a slightly greater uncertainty due to a small degree of spatial autocorrelation.

```{r, fig.width=12,fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_lmer_rand <- broom.mixed::tidy(mod_mixed_lmer, effects="ran_vals", conf.int=TRUE) |> 
  filter(term != "(Intercept)") |> 
  select(-effect,-group) |> 
  rename(effect = term,
         lower_2.5 = conf.low,
         upper_97.5 = conf.high,
         value = estimate,
         group = level,
         se = std.error)
mod_mixed_lmer_rand$model = rep("mod_mixed_lmer",nrow(mod_mixed_lmer_rand))

mod_mixed_lmer_rand$effect <- fct_reorder(mod_mixed_lmer_rand$effect, mod_mixed_lmer_rand$value)
mod_mixed_lmer_rand$swingto <- case_when(mod_mixed_lmer_rand$value>0 ~ "Conservative",
                              TRUE ~ "Labour")

mod_mixed_gam_v1_random <- extract_ranef(mod_mixed_gam_v1) |> 
  select(-group_var) |> 
  mutate(model = rep("mod_mixed_gam_v1",nrow(mod_mixed_gam_v1_random)))

mod_mixed_gam_v1_random$effect <- fct_reorder(mod_mixed_gam_v1_random$effect, mod_mixed_gam_v1_random$value)
mod_mixed_gam_v1_random$swingto <- case_when(mod_mixed_gam_v1_random$value>0 ~ "Conservative",
                              TRUE ~ "Labour")

two_mods <- rbind(mod_mixed_lmer_rand,mod_mixed_gam_v1_random)

ggplot(two_mods, aes(x=value, y=group,
                     xmin=lower_2.5,
                     xmax=upper_97.5, 
                     fill=model,
                     colour=model,
                     group=model)) +
  geom_errorbar(lwd=0.8,position = position_dodge(width=0.8)) + 
  geom_point(shape=21, size=1.5,position = position_dodge(width=0.8)) + 
  geom_vline(xintercept = 0, colour="red") + 
  # scale_colour_manual(values = c("darkblue","#DE8E89")) + 
  # scale_fill_manual(values = c("darkblue","#DE8E89")) + 
  scale_colour_manual(values = c("darkblue","saddlebrown")) + 
  scale_fill_manual(values = c("darkblue","saddlebrown")) + 
  facet_grid(~effect) + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(override.aes = list(size = 4))) + 
  labs(x="coef effect", 
       y=NULL, 
       title = "Comparison of random effects",
       subtitle = "mod_mixed_lmer and mod_mixed_gam_v1") + 
  guides(colour="none")

```

## Comparison of mixed and spatial mixed v2

Using mixed: `mod_mixed_lmer`

Using spatial: `mod_mixed_gam_v2`

```{r, fig.width=12,fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

mod_mixed_lmer_rand <- broom.mixed::tidy(mod_mixed_lmer, effects="ran_vals", conf.int=TRUE) |> 
  filter(term != "(Intercept)") |> 
  select(-effect,-group) |> 
  rename(effect = term,
         lower_2.5 = conf.low,
         upper_97.5 = conf.high,
         value = estimate,
         group = level,
         se = std.error)
mod_mixed_lmer_rand$model = rep("mod_mixed_lmer",nrow(mod_mixed_lmer_rand))

mod_mixed_lmer_rand$effect <- fct_reorder(mod_mixed_lmer_rand$effect, mod_mixed_lmer_rand$value)
mod_mixed_lmer_rand$swingto <- case_when(mod_mixed_lmer_rand$value>0 ~ "Conservative",
                              TRUE ~ "Labour")

# bring back gam_v2 dataframes from before...
temp <- mod_mixed_gam_v2_df_reg[,c(1,6:10,15:19)] |> 
  st_drop_geometry()
temp1 <- temp[,1:6] |> 
  pivot_longer(2:6, 
               names_to = "variable",
               values_to = "effect")
temp2 <- temp[,c(1,7:11)] |> 
  pivot_longer(2:6, 
               names_to = "variable",
               values_to = "std_error")
temp3 <- cbind(temp1,temp2[,3])

temp3$variable <- str_remove(temp3$variable, "s.")

temp3$conf_lower <- temp3$effect - qnorm(0.975)*temp3$std_error
temp3$conf_upper <- temp3$effect + qnorm(0.975)*temp3$std_error

temp3$variable <- str_remove(temp3$variable, "fit.")

temp4 <- temp3 |> 
  rename(group = county,
         value = effect,
         effect = variable,
         se = std_error,
         lower_2.5 = conf_lower,
         upper_97.5 = conf_upper) |> 
  filter(effect!="county.")
temp4$model <- rep("mod_mixed_gam_v2",nrow(temp4))
temp4$swingto <- case_when(temp4$value>0 ~ "Conservative",
                              TRUE ~ "Labour")
temp4$effect <- str_remove(temp4$effect, "county..")

two_mods2 <- rbind(mod_mixed_lmer_rand,temp4)

ggplot(two_mods2, aes(x=value, y=group,
                     xmin=lower_2.5,
                     xmax=upper_97.5, 
                     fill=model,
                     colour=model,
                     group=model)) +
  geom_errorbar(lwd=0.8,position = position_dodge(width=0.8)) + 
  geom_point(shape=21, size=1.5,position = position_dodge(width=0.8)) + 
  geom_vline(xintercept = 0, colour="red") + 
  # scale_colour_manual(values = c("darkblue","#DE8E89")) + 
  # scale_fill_manual(values = c("darkblue","#DE8E89")) + 
  scale_colour_manual(values = c("darkblue","saddlebrown")) + 
  scale_fill_manual(values = c("darkblue","saddlebrown")) + 
  facet_grid(~effect) + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(override.aes = list(size = 4))) + 
  labs(x="coef effect", 
       y=NULL, 
       title = "Comparison of random effects",
       subtitle = "mod_mixed_lmer and mod_mixed_gam_v2") + 
  guides(colour="none")

```


The three models together:

```{r, fig.width=12,fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

three_mods <- rbind(two_mods,temp4)

firstgroupcounties <- counties$county[1:27]
secondgroupcounties <- counties$county[28:53]

three_mods1 <- three_mods |> filter(group %in% firstgroupcounties) 
three_mods2 <- three_mods |> filter(group %in% secondgroupcounties)

ggplot(three_mods1, 
       aes(x=value, y=group,
           xmin=lower_2.5,
           xmax=upper_97.5, 
           fill=model,
           colour=model,
           group=model)) +
  geom_errorbar(lwd=0.8,position = position_dodge(width=0.8)) + 
  geom_point(shape=21, size=1.5,position = position_dodge(width=0.8)) + 
  geom_vline(xintercept = 0, colour="red") + 
  # scale_colour_manual(values = c("darkblue","#DE8E89")) + 
  # scale_fill_manual(values = c("darkblue","#DE8E89")) + 
  scale_colour_manual(values = c("darkgreen","darkblue","saddlebrown")) + 
  scale_fill_manual(values = c("darkgreen","darkblue","saddlebrown")) + 
  facet_grid(~effect) + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(override.aes = list(size = 4))) + 
  labs(x="coef effect", 
       y=NULL, 
       title = "Comparison of random effects",
       subtitle = "mod_mixed_lmer, mod_mixed_gam_v1, and mod_mixed_gam_v2") + 
  guides(colour="none")



```

```{r, fig.width=12,fig.height=12}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

ggplot(three_mods2, 
       aes(x=value, y=group,
           xmin=lower_2.5,
           xmax=upper_97.5, 
           fill=model,
           colour=model,
           group=model)) +
  geom_errorbar(lwd=0.8,position = position_dodge(width=0.8)) + 
  geom_point(shape=21, size=1.5,position = position_dodge(width=0.8)) + 
  geom_vline(xintercept = 0, colour="red") + 
  # scale_colour_manual(values = c("darkblue","#DE8E89")) + 
  # scale_fill_manual(values = c("darkblue","#DE8E89")) + 
  scale_colour_manual(values = c("darkgreen","darkblue","saddlebrown")) + 
  scale_fill_manual(values = c("darkgreen","darkblue","saddlebrown")) + 
  facet_grid(~effect) + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(override.aes = list(size = 4))) + 
  labs(x="coef effect", 
       y=NULL, 
       title = "Comparison of random effects",
       subtitle = "mod_mixed_lmer, mod_mixed_gam_v1, and mod_mixed_gam_v2") + 
  guides(colour="none")



```


## Likelihood ratio tests

LR tests:
 
If I am interpreting correctly, the likelihood ratio tests seem to show that:
 
Mixed models are better than simple linear models (as expected): comparing mod_lm (re-expressed as mod_gls), to mod_mixed_nlme.
 
The model which also allows spatial relationships within regions (mod_nlme_corExp) is better than mod_mixed_nlme (and I suppose the other two identical but differently expressed models lmer and gam).
 
The mod_mixed_gam_v1 with contiguity relationship between regions is also better than the three basic mixed model version.
 
However, Im not sure if I can perform a LRT between mod_nlme_corExp and mod_mixed_gam_v1 or mod_mixed_gam_v2 to decide which is better.

```{r}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

###

lm_mrf_lrt_df <- anova(mod_lm,mod_lm_mrf) |> 
  mutate(model = c("mod_lm","mod_lm_mrf")) |> 
  select(model, everything())

kbl(lm_mrf_lrt_df, caption="LM/MRF models: Likelihood ratio test p-values") |> 
  kable_classic(full_width = F, html_font = "Cambria")

###

# express mod_lm as a gls from nlme package for anova comparison

mod_gls <- gls(con_swing ~
               degree_educated +
               younger_adults +
               health_not_good +
               white,
             data=df_scaled_sf)

gls_lrt_df <- anova(mod_gls,mod_mixed_nlme)[,-1] # which is the same model as mod_mix_lmer and mod_mixed_gam

kbl(gls_lrt_df, caption="GLS models: Likelihood ratio test p-values") |> 
  kable_classic(full_width = F, html_font = "Cambria")

###

nlme_list <- list()

nlme_list[[1]] <- mod_mixed_nlme
nlme_list[[2]] <- mod_nlme_corExp
nlme_list[[3]] <- mod_nlme_corLin
nlme_list[[4]] <- mod_nlme_corGaus

nlme_lrt_df <- data.frame(
  model = c("mod_mixed_nlme","mod_nlme_corExp","mod_nlme_corLin","mod_nlme_corGaus"),
  mod_mixed_nlme = c(
    "-",
    round((anova(nlme_list[[1]],nlme_list[[2]]))$`p-value`[2],3),
    round((anova(nlme_list[[1]],nlme_list[[3]]))$`p-value`[2],3),
    round((anova(nlme_list[[1]],nlme_list[[4]]))$`p-value`[2],3)
  )
    )

kbl(nlme_lrt_df, caption="NLME models: Likelihood ratio test p-values") |> 
  kable_classic(full_width = F, html_font = "Cambria")

###

gam_list <- list()

gam_list[[1]] <- mod_mixed_gam
gam_list[[2]] <- mod_mixed_gam_v1
gam_list[[3]] <- mod_mixed_gam_v2

library(lmtest)
lrt_1 <- lrtest(mod_mixed_gam,mod_mixed_gam_v1)
lrt_2 <- lrtest(mod_mixed_gam,mod_mixed_gam_v2)
lrt_3 <- lrtest(mod_mixed_gam_v1,mod_mixed_gam_v2)

gam_lrt_df <- data.frame(
  model = c("mod_mixed_gam","mod_mixed_gam_v1","mod_mixed_gam_v2"),
  mod_mixed_gam = c(
    "-",
    round(lrt_1$`Pr(>Chisq)`[2],3),
    round(lrt_2$`Pr(>Chisq)`[2],3)
  ),
  mod_mixed_gam_v1 = c(
    "-",
    "-",
    round(lrt_3$`Pr(>Chisq)`[2],3)
  ),
  mod_mixed_gam_v2 = c(
    "-",
    "-",
    "-"
  )
)

kbl(gam_lrt_df, caption="GAM models: Likelihood ratio test p-values") |> 
  kable_classic(full_width = F, html_font = "Cambria")

###



```


## Spatial effects on coefficients together

```{r, fig.width=10, fig.height=6}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

dorl_mod_mixed_lmer
dorl_mod_mixed_gam_v1
dorl_mod_mixed_gam_v2

dorl_mod_mixed_lmer_p2
dorl_mod_mixed_gam_v1_p2
dorl_mod_mixed_gam_v2_p2
```


## Make new pseudo-regions

```{r, fig.width=10, fig.height=10}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

countynb <- poly2nb(mod_mixed_gam_v2_df_reg, queen = TRUE)

# fix Isle of Wight contiguity
countynb[[26]]<-22 |> 
  as.integer()
countynb[[22]]<-c(3, 13, 26, 46, 51, 53) |> 
  as.integer()

dat <- mod_mixed_gam_v2_df_reg |> 
  select(fit.s.county.,fit.s.county..degree_educated,fit.s.county..younger_adults,fit.s.county..health_not_good,fit.s.county..white) |> 
  st_drop_geometry() |> 
  apply(2,scale) |> 
  data.frame() |> 
  mutate(geometry = mod_mixed_gam_v2_df_reg$geometry) |> 
  st_as_sf() |> 
  as_Spatial()

vars <- c("fit.s.county.",
          "fit.s.county..degree_educated",
          "fit.s.county..younger_adults",
          "fit.s.county..health_not_good",
          "fit.s.county..white"
  
)

sdat <- data.frame(dat@data[,vars])
# edge costs - dissimilarity between node and its neighbours
lcosts <- nbcosts(countynb,sdat)

# make this into a weights object
# style is B to make sure cost values are not row-standardised
df.w <- nb2listw(countynb,lcosts,style = "B")

# create minimum spanning tree
df.mst <- mstree(df.w)

# plot(df.mst,coordinates(dat),col="blue",
#       cex.lab=0.7)
# plot(dat,border=gray(.5),add=TRUE)

# skater function for contiguity-constrained cluster
total_clusters <- 12
tc <- total_clusters-1

clusts <- spdep::skater(df.mst[,1:2],sdat,tc,crit = 1)

df_clus <- mod_mixed_gam_v2_df_reg |> 
  st_as_sf() |> 
  mutate(clus = factor(clusts$groups, 
                       levels = c("1","2","3","4","5","6","7","8","9","10","11","12"))) |> 
  st_transform(crs=27700)

ggplot() + 
  geom_sf(data=df_clus, aes(fill=clus), linewidth=0.1, colour="gray10") + 
  scale_fill_brewer(palette = "Set3", direction = 1) +
  geom_sf(data=regions, aes(fill=NA), linewidth=0.5) + 
  geom_sf_label(data=df_clus, aes(label=county), size=2) + 
  theme_bw() + 
  theme(axis.title.x = element_blank()) + 
  theme(axis.title.y = element_blank())

```





```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

county_swing <- df_sc_county |> 
  group_by(county) |> 
  summarise(mean_con_swing = mean(con_swing))

group_clus <- df_clus |> 
  mutate(con_swing = county_swing$mean_con_swing) |> 
  group_by(clus) |> 
  summarise(intercept = mean(fit.s.county.),
          degree_educated = mean(fit.s.county..degree_educated),
          health_not_good = mean(fit.s.county..health_not_good),
          white = mean(fit.s.county..white),
          younger_adults = mean(fit.s.county..younger_adults),
          sd_intercept = sd(fit.s.county.),
          sd_degree_educated = sd(fit.s.county..degree_educated),
          sd_health_not_good = sd(fit.s.county..health_not_good),
          sd_white = sd(fit.s.county..white),
          sd_younger_adults = sd(fit.s.county..younger_adults),
          con_swing = mean(con_swing))

gr1 <- ggplot(group_clus) + 
  geom_sf(aes(fill=intercept)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "intercept",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr2 <- ggplot(group_clus) + 
  geom_sf(aes(fill=degree_educated)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "degree_educated",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr3 <- ggplot(group_clus) + 
  geom_sf(aes(fill=health_not_good)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "health_not_good",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr4 <- ggplot(group_clus) + 
  geom_sf(aes(fill=white)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "white",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr5 <- ggplot(group_clus) + 
  geom_sf(aes(fill=younger_adults)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "younger_adults",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

ggarrange(gr1, gr2, gr3, gr4, gr5, nrow = 1, common.legend = TRUE, legend = "bottom")

```


```{r, fig.width=12, fig.height=10}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

col1 <- ggplot() + 
  geom_sf(data=df_clus, aes(fill=clus), linewidth=0.1, colour="gray10") + 
  scale_fill_brewer(palette = "Set3", direction = 1) +
  geom_sf(data=regions, aes(fill=NA), linewidth=0.5) + 
  geom_sf_label(data=df_clus, aes(label=county), size=2) + 
  labs(fill = "pseudo-region") + 
  theme_bw() + 
  theme(axis.title.x = element_blank()) + 
  theme(axis.title.y = element_blank()) + 
  theme(legend.position = "bottom")

col2 <- ggarrange(gr1, gr2, gr3, gr4, gr5, ncol = 1, common.legend = TRUE, legend = "top")

col3 <- ggarrange(col1,col2, widths = c(3,1))

col3

```

### Upper quintile of swing

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

ordered_swing <- county_swing |> 
  arrange(desc(mean_con_swing))

gr1_uq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=intercept)) + 
  geom_sf(data=ordered_swing[1:11,], fill=NA, colour="gray0", linewidth=0.75) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "intercept",
       subtitle = "mean county effect", 
       fill = "upper quintile county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr2_uq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=degree_educated)) + 
  geom_sf(data=ordered_swing[1:11,], fill=NA, colour="gray0", linewidth=0.75) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "degree_educated",
       subtitle = "mean county effect", 
       fill = "upper quintile county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr3_uq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=health_not_good)) + 
  geom_sf(data=ordered_swing[1:11,], fill=NA, colour="gray0", linewidth=0.75) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "health_not_good",
       subtitle = "mean county effect", 
       fill = "upper quintile county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr4_uq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=white)) + 
  geom_sf(data=ordered_swing[1:11,], fill=NA, colour="gray0", linewidth=0.75) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "white",
       subtitle = "mean county effect", 
       fill = "upper quintile county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr5_uq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=younger_adults)) + 
  geom_sf(data=ordered_swing[1:11,], fill=NA, colour="gray0", linewidth=0.75) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "younger_adults",
       subtitle = "mean county effect", 
       fill = "upper quintile county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

ggarrange(gr1_uq, gr2_uq, gr3_uq, gr4_uq, gr5_uq, nrow = 1, common.legend = TRUE, legend = "bottom")

```



### Lower quintile of swing

```{r, fig.width=12, fig.height=4}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

ordered_swing <- county_swing |> 
  arrange(desc(mean_con_swing))

gr1_lq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=intercept)) + 
  geom_sf(data=ordered_swing[42:52,], fill=NA, colour="gray0", linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "intercept",
       fill = "lower quintile mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr2_lq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=degree_educated)) + 
  geom_sf(data=ordered_swing[42:52,], fill=NA, colour="gray0", linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "degree_educated",
       fill = "lower quintile mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr3_lq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=health_not_good)) + 
  geom_sf(data=ordered_swing[42:52,], fill=NA, colour="gray0", linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "health_not_good",
       fill = "lower quintile mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr4_lq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=white)) + 
  geom_sf(data=ordered_swing[42:52,], fill=NA, colour="gray0", linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "white",
       fill = "lower quintile mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

gr5_lq <- ggplot() + 
  geom_sf(data=group_clus, aes(fill=younger_adults)) + 
  geom_sf(data=ordered_swing[42:52,], fill=NA, colour="gray0", linewidth=0.5) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-1.8,1.8)) + 
  labs(title = "younger_adults",
       fill = "lower quintile mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

ggarrange(gr1_lq, gr2_lq, gr3_lq, gr4_lq, gr5_lq, nrow = 1, common.legend = TRUE, legend = "bottom")

```


### Pseudo-regions separately by covariate

```{r, fig.width=10, fig.height=10}
#| code-fold: false
#| message: false
#| warning: false
#| echo: false

# degree
dat <- mod_mixed_gam_v2_df_reg |> 
  select(fit.s.county.,fit.s.county..degree_educated) |> 
  st_drop_geometry() |> 
  apply(2,scale) |> 
  data.frame() |> 
  mutate(geometry = mod_mixed_gam_v2_df_reg$geometry) |> 
  st_as_sf() |> 
  as_Spatial()

vars <- c("fit.s.county.",
          "fit.s.county..degree_educated")

sdat <- data.frame(dat@data[,vars])
# edge costs - dissimilarity between node and its neighbours
lcosts <- nbcosts(countynb,sdat)

# make this into a weights object
# style is B to make sure cost values are not row-standardised
df.w <- nb2listw(countynb,lcosts,style = "B")

# create minimum spanning tree
df.mst <- mstree(df.w)

total_clusters <- 12
tc <- total_clusters-1

clusts <- spdep::skater(df.mst[,1:2],sdat,tc,crit = 1)

df_clus <- mod_mixed_gam_v2_df_reg |> 
  st_as_sf() |> 
  mutate(clus = factor(clusts$groups, 
                       levels = c("1","2","3","4","5","6","7","8","9","10","11","12"))) |> 
  st_transform(crs=27700)

degree_plot <- ggplot() + 
  geom_sf(data=df_clus, aes(fill=clus), linewidth=0.1, colour="gray10") + 
  scale_fill_brewer(palette = "Set3", direction = 1) +
  #geom_sf(data=regions, aes(fill=NA), linewidth=0.5) + 
  #geom_sf_label(data=df_clus, aes(label=county), size=2) + 
  coord_sf(datum=NA) + 
  theme_bw() + 
  theme(axis.title.x = element_blank()) + 
  theme(axis.title.y = element_blank()) + 
  labs(title = "degree_educated") + 
  guides(fill= FALSE)

county_swing <- df_sc_county |> 
  group_by(county) |> 
  summarise(mean_con_swing = mean(con_swing))

group_clus <- df_clus |> 
  mutate(con_swing = county_swing$mean_con_swing) |> 
  group_by(clus) |> 
  summarise(degree_educated = mean(fit.s.county..degree_educated))

degree_plot2 <- ggplot(group_clus) + 
  geom_sf(aes(fill=degree_educated)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-2,2)) + 
  labs(title = "degree_educated",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

# younger_adults
dat <- mod_mixed_gam_v2_df_reg |> 
  select(fit.s.county.,fit.s.county..younger_adults) |> 
  st_drop_geometry() |> 
  apply(2,scale) |> 
  data.frame() |> 
  mutate(geometry = mod_mixed_gam_v2_df_reg$geometry) |> 
  st_as_sf() |> 
  as_Spatial()

vars <- c("fit.s.county.",
          "fit.s.county..younger_adults")

sdat <- data.frame(dat@data[,vars])
# edge costs - dissimilarity between node and its neighbours
lcosts <- nbcosts(countynb,sdat)

# make this into a weights object
# style is B to make sure cost values are not row-standardised
df.w <- nb2listw(countynb,lcosts,style = "B")

# create minimum spanning tree
df.mst <- mstree(df.w)

total_clusters <- 12
tc <- total_clusters-1

clusts <- spdep::skater(df.mst[,1:2],sdat,tc,crit = 1)

df_clus <- mod_mixed_gam_v2_df_reg |> 
  st_as_sf() |> 
  mutate(clus = factor(clusts$groups, 
                       levels = c("1","2","3","4","5","6","7","8","9","10","11","12"))) |> 
  st_transform(crs=27700)

young_plot <- ggplot() + 
  geom_sf(data=df_clus, aes(fill=clus), linewidth=0.1, colour="gray10") + 
  scale_fill_brewer(palette = "Set3", direction = 1) +
  #geom_sf(data=regions, aes(fill=NA), linewidth=0.5) + 
  #geom_sf_label(data=df_clus, aes(label=county), size=2) + 
  coord_sf(datum=NA) + 
  theme_bw() + 
  theme(axis.title.x = element_blank()) + 
  theme(axis.title.y = element_blank()) + 
  labs(title = "younger_adults") + 
  guides(fill= FALSE)

group_clus <- df_clus |> 
  mutate(con_swing = county_swing$mean_con_swing) |> 
  group_by(clus) |> 
  summarise(younger_adults = mean(fit.s.county..younger_adults))

young_plot2 <- ggplot(group_clus) + 
  geom_sf(aes(fill=younger_adults)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-2,2)) + 
  labs(title = "younger_adults",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

# health_not_good
dat <- mod_mixed_gam_v2_df_reg |> 
  select(fit.s.county.,fit.s.county..health_not_good) |> 
  st_drop_geometry() |> 
  apply(2,scale) |> 
  data.frame() |> 
  mutate(geometry = mod_mixed_gam_v2_df_reg$geometry) |> 
  st_as_sf() |> 
  as_Spatial()

vars <- c("fit.s.county.",
          "fit.s.county..health_not_good")

sdat <- data.frame(dat@data[,vars])
# edge costs - dissimilarity between node and its neighbours
lcosts <- nbcosts(countynb,sdat)

# make this into a weights object
# style is B to make sure cost values are not row-standardised
df.w <- nb2listw(countynb,lcosts,style = "B")

# create minimum spanning tree
df.mst <- mstree(df.w)

total_clusters <- 12
tc <- total_clusters-1

clusts <- spdep::skater(df.mst[,1:2],sdat,tc,crit = 1)

df_clus <- mod_mixed_gam_v2_df_reg |> 
  st_as_sf() |> 
  mutate(clus = factor(clusts$groups, 
                       levels = c("1","2","3","4","5","6","7","8","9","10","11","12"))) |> 
  st_transform(crs=27700)

health_plot <- ggplot() + 
  geom_sf(data=df_clus, aes(fill=clus), linewidth=0.1, colour="gray10") + 
  scale_fill_brewer(palette = "Set3", direction = 1) +
  #geom_sf(data=regions, aes(fill=NA), linewidth=0.5) + 
  #geom_sf_label(data=df_clus, aes(label=county), size=2) + 
  coord_sf(datum=NA) + 
  theme_bw() + 
  theme(axis.title.x = element_blank()) + 
  theme(axis.title.y = element_blank()) + 
  labs(title = "health_not_good") + 
  guides(fill= FALSE)

group_clus <- df_clus |> 
  mutate(con_swing = county_swing$mean_con_swing) |> 
  group_by(clus) |> 
  summarise(health_not_good = mean(fit.s.county..health_not_good))

health_plot2 <- ggplot(group_clus) + 
  geom_sf(aes(fill=health_not_good)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-2,2)) + 
  labs(title = "health_not_good",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

# white
dat <- mod_mixed_gam_v2_df_reg |> 
  select(fit.s.county.,fit.s.county..white) |> 
  st_drop_geometry() |> 
  apply(2,scale) |> 
  data.frame() |> 
  mutate(geometry = mod_mixed_gam_v2_df_reg$geometry) |> 
  st_as_sf() |> 
  as_Spatial()

vars <- c("fit.s.county.",
          "fit.s.county..white")

sdat <- data.frame(dat@data[,vars])
# edge costs - dissimilarity between node and its neighbours
lcosts <- nbcosts(countynb,sdat)

# make this into a weights object
# style is B to make sure cost values are not row-standardised
df.w <- nb2listw(countynb,lcosts,style = "B")

# create minimum spanning tree
df.mst <- mstree(df.w)

total_clusters <- 12
tc <- total_clusters-1

clusts <- spdep::skater(df.mst[,1:2],sdat,tc,crit = 1)

df_clus <- mod_mixed_gam_v2_df_reg |> 
  st_as_sf() |> 
  mutate(clus = factor(clusts$groups, 
                       levels = c("1","2","3","4","5","6","7","8","9","10","11","12"))) |> 
  st_transform(crs=27700)

white_plot <- ggplot() + 
  geom_sf(data=df_clus, aes(fill=clus), linewidth=0.1, colour="gray10") + 
  scale_fill_brewer(palette = "Set3", direction = 1) +
  #geom_sf(data=regions, aes(fill=NA), linewidth=0.5) + 
  #geom_sf_label(data=df_clus, aes(label=county), size=2) + 
  coord_sf(datum=NA) + 
  theme_bw() + 
  theme(axis.title.x = element_blank()) + 
  theme(axis.title.y = element_blank()) + 
  labs(title = "white") + 
  guides(fill= FALSE)

group_clus <- df_clus |> 
  mutate(con_swing = county_swing$mean_con_swing) |> 
  group_by(clus) |> 
  summarise(white = mean(fit.s.county..white))

white_plot2 <- ggplot(group_clus) + 
  geom_sf(aes(fill=white)) + 
  scale_fill_gradient2(low="darkred",mid="white",high="darkblue",midpoint = 0, limits=c(-2,2)) + 
  labs(title = "white",
       fill = "mean county effect") + 
  coord_sf(datum=NA) + 
  theme_bw()

ggarrange(degree_plot,degree_plot2,
          young_plot,young_plot2,
          health_plot,health_plot2,
          white_plot,white_plot2,
          nrow = 4, ncol = 2)

```
